package de.tu_darmstadt.veritas.VerificationInfrastructure.lemmagen

import java.io.StringWriter

import de.tu_darmstadt.veritas.VerificationInfrastructure.lemmagen.Lemma
import de.tu_darmstadt.veritas.backend.ast.function.FunctionDef
import de.tu_darmstadt.veritas.backend.util.prettyprint.PrettyPrintWriter
import de.tu_darmstadt.veritas.scalaspl.prettyprint.SimpleToScalaSPLSpecificationPrinter
import scalafix.internal.patch.PatchInternals

import scala.meta._
import scalafix.v1._

import scala.meta.inputs.Input

/** Update a ScalaSPL specification with a set of generated lemmas and @...Property annotations.
  * This class is implemented using ScalaFix. */
class ScalaSPLSpecificationOutput(input: Input,
                                  lemmas: Seq[Lemma],
                                  annotationsToAdd: Seq[(String, String, String)]) {

  def this(fromString: String, lemmas: Seq[Lemma], annotationsToAdd: Seq[(String, String, String)]) = {
    this(Input.VirtualFile("test.scala", fromString), lemmas, annotationsToAdd)
  }

  /** Construct a ScalaFix Patch that adds a @...Property annotation. */
  def addDSKAnnotation(doc: SyntacticDocument,
                       functionName: String,
                       annotationName: String,
                       lemmaName: String): Patch = {
    doc.tree.collect {
      case fn@Defn.Def(_, Term.Name(foundName), _, _, _, _) if foundName == functionName =>
        // we have found ``functionName``, we add an annotation
        val lemmaString = "\"" + lemmaName + "\""
        val annotation = s"@$annotationName($lemmaString)"
        Patch.addLeft(fn, annotation + "\n  ")
    }.asPatch
  }

  /** Write all lemmas to a string and return it.
    * @param preamble Add a comment that lemmas have been autogenerated
    * @param indent Indent all lemmas with 2 spaces
    * @return
    */
  def makeLemmasString(preamble: Boolean = true, indent: Boolean = true): String = {
    val writer = new StringWriter()
    val prettyWriter = new PrettyPrintWriter(writer)
    if(indent)
      prettyWriter.indent() // we use a default indentation of 2 spaces
    val lemmaWriter = new SimpleToScalaSPLSpecificationPrinter {
      override val printer: PrettyPrintWriter = prettyWriter
    }
    if(preamble) {
      prettyWriter.writeln("// The following lemmas have been automatically generated.")
      prettyWriter.newline()
    }
    var first = true
    for(lemma <- lemmas) {
      if(!first) {
        prettyWriter.newline()
      } else {
        first = false
      }
      prettyWriter.write("@Property")
      prettyWriter.newline()
      lemmaWriter.printTypingRule(lemma)
      prettyWriter.flush()
    }
    writer.toString
  }

  /** Construct a ScalaFix Patch that adds all lemmas to the specification. */
  def addLemmas(doc: SyntacticDocument): Patch = {
    val lemmasString = makeLemmasString()
    doc.tree.collect {
      case obj@Defn.Object(_, _, Template(_, _, self, stats)) =>
        // we have found the top-level object, add the lemma
        Patch.addLeft(obj.tokens.last, lemmasString)
    }.asPatch
  }

  /** Construct an extended specification and return it. */
  def generate(): String = {
    val doc = SyntacticDocument.fromInput(input)
    // Construct a ScalaFix Patch that adds DSK annotations to functions
    var dskPatch = Patch.empty
    for((functionName, annotationName, lemmaName) <- annotationsToAdd) {
      dskPatch += addDSKAnnotation(doc, functionName, annotationName, lemmaName)
    }
    // Construct a ScalaFix Patch that adds lemmas
    val lemmaPatch = addLemmas(doc)
    // Apply the patch using internal ScalaFix functions
    PatchInternals.syntactic(
      Map(RuleName("AddDSKAnnotations") -> dskPatch, RuleName("AddLemmas") -> lemmaPatch),
      doc, suppress = true)._1
  }
}

object ScalaSPLSpecificationOutput {
  /** Return a lexicographically sorted list of 3-tuples (function name, DSK annotation name, lemma name) */
  private def flattenLemmas(allLemmas: Map[FunctionDef, Seq[Lemma]],
                            annotation: String): Seq[(String, String, String)] = {
    allLemmas.flatMap {
      case (fn, lemmas) => lemmas.map(lemma => (fn.signature.name, annotation, lemma.name))
    }.toSeq.sorted // sort lexicographically
  }

  /** Given a ScalaSPL specification input and progress and preservation lemmas, generate
    * and return an updated ScalaSPL specification. */
  def addLemmasToSpecification(input: Input,
                               progressLemmas: Map[FunctionDef, Seq[Lemma]],
                               preservationLemmas: Map[FunctionDef, Seq[Lemma]]): String = {
    makeWriter(input, progressLemmas, preservationLemmas).generate()
  }

  /** Create a ScalaSPLSpecificationOutput instance for the given input and progress and preservation lemmas */
  private def makeWriter(input: Input,
                        progressLemmas: Map[FunctionDef, Seq[Lemma]],
                        preservationLemmas: Map[FunctionDef, Seq[Lemma]]): ScalaSPLSpecificationOutput = {
    val annotations = (flattenLemmas(progressLemmas, "ProgressProperty")
      ++ flattenLemmas(preservationLemmas, "PreservationProperty"))
    // sort lemmas by name
    val lemmas = (progressLemmas.flatMap(_._2).toSeq ++ preservationLemmas.flatMap(_._2).toSeq).sortBy(_.name)
    new ScalaSPLSpecificationOutput(input, lemmas, annotations)
  }

  /** Given a ScalaSPL specification as a String as well as progress and preservation lemmas,
    * generate and return an updated ScalaSPL specification. */
  def addLemmasToSpecification(input: String,
                               progressLemmas: Map[FunctionDef, Seq[Lemma]],
                               preservationLemmas: Map[FunctionDef, Seq[Lemma]]): String = {
    addLemmasToSpecification(Input.VirtualFile("placeholder.scala", input), progressLemmas, preservationLemmas)
  }

  /** Generate a simple ScalaSPL string that contains the given lemmas, without any preamble and indentation. */
  def generateLemmasString(input: Input,
                           progressLemmas: Map[FunctionDef, Seq[Lemma]],
                           preservationLemmas: Map[FunctionDef, Seq[Lemma]]): String = {
    makeWriter(input, progressLemmas, preservationLemmas).makeLemmasString(preamble = false, indent = false)
  }
}