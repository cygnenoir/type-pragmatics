module Veritas

imports Language


lexical syntax

  RuleSep = "===" "="* 
  Name = [a-zA-Z0-9\-]+ 

lexical restrictions

  RuleSep -/- [\=]

context-free syntax

RuleSepName.RuleName = 
<<RuleSep> <Name>> {layout("1.first.line == 2.last.line")}

TypingRule.TypingRule = 
<<TypingRulePremises> 
<RuleSepName> 
<TypingRuleConsequences>

> {layout("1.first.col == 2.first.col && 2.first.col == 3.first.col && 1.last.line + num(1) == 2.first.line")}

TypingRule.TypingRule = 
<
<RuleSepName> 
<TypingRuleConsequences>

> {layout("1.first.col == 2.first.col")}

TypingRulePremises.PremiseList = 
TypingRuleJudgementList 

TypingRuleConsequences.ConsequenceList = 
TypingRuleJudgementList 

TypingRuleJudgementList = 
OffTypingRuleJudgment 

TypingRuleJudgementList.JudgementCons = 
<
<OffTypingRuleJudgment> 
<TypingRuleJudgementList>

> {layout("1.first.col == 2.first.col && 2.first.line - 1.last.line == num(1)")}

OffTypingRuleJudgment = 
TypingRuleJudgment {layout("1.first.col < 1.left.col")}

OffTypingRuleJudgment = 
OrTypingRuleJudgement 
  
OrTypingRuleJudgement.OrJudgement = 
<OR 
<OrCaseList>>
 
OrCaseList.OrEnd = 
<=\> <TypingRuleJudgementList>
>
 
OrCaseList.OrCons = 
<=\> <TypingRuleJudgementList> <OrCaseList>
> {layout("1.first.col == 3.first.col")}

TypingJudgment.TypingJudgment = 
<<FunctionExp> |- <FunctionExp> : <FunctionExp>> 

TypingJudgment.TypingJudgmentSimple = 
<<FunctionExp> : <FunctionExp>>

FunctionExpJudgment.FunctionExpJudgment = 
FunctionExp 

ReduceJudgment.ReduceJudgment = 
<<FunctionExp> -\> <FunctionExp>> 

ExistsJudgment.ExistsJudgment = 
<exists <{MetaVar ","}+> 
<TypingRuleJudgementList>
> {layout("1.first.col < 3.first.col")}

ExistsJudgment.ForallJudgment = 
<forall <{MetaVar ","}+> 
<TypingRuleJudgementList>
> {layout("1.first.col < 3.first.col")}

NotJudgment.NotJudgment = 
<not <TypingRuleJudgment>> 

TypingRuleJudgment = TypingJudgment 
  
TypingRuleJudgment = FunctionExpJudgment 

TypingRuleJudgment = ExistsJudgment 

TypingRuleJudgment = ReduceJudgment 

TypingRuleJudgment = NotJudgment 

sorts

  Module Rules DerivedRules Import ModuleDec Qualified Definitions

lexical syntax

  SortLex = [a-zA-Z] [a-zA-Z0-9]* 

lexical restrictions

  SortLex -/- [a-zA-Z0-9]

context-free syntax

SortDef.SortDef = SortLex 

SortRef.SortRef = SortLex 

ConstructorDecl.ConstructorDecl = 
<<ID> : <SortRef+> -\> <SortRef>

> 
  
ConstructorDecl = ConstDecl 

ConstDecl = 
<<ID> : <SortRef>

> {ast("ConstructorDecl(<1>, [], <2>)")}

context-free syntax

FunctionDef.FunctionDef = 
<<FunctionSig> 
<FunctionEq*>

>

FunctionSig.FunctionSig = 
<<ID> : <SortRef+> -\> <SortRef>> 

FunctionSig = 
<<ID> : <SortRef>> {ast("FunctionSig(<1>, [], <2>)")}

FunctionEq = 
<<ID> = <FunctionExp>

> {ast("FunctionEq(<1>, [], <2>)")}

FunctionEq.FunctionEq = 
<<ID>(<{FunctionPattern ","}*>) = <FunctionExp>

>
 
RelationDef.FunctionDef = 
<<RelationSig> 
<RelationEq+>

>
 
RelationSig = 
<<ID> : <SortRef+>> {ast("FunctionSig(<1>, <2>, RelBool())")}

RelationEq.FunctionEq = 
<<ID>(<{FunctionPattern ","}*>) \<= <FunctionExp>

> 

RelationEq = 
<<ID>(<{FunctionPattern ","}*>)

> {ast("FunctionEq(<1>, <2>, FunctionExpTrue())")}

FunctionExp.FunctionExpUndefined = 
<undefined>
 
FunctionExp.FunctionExpTrue = 
<true>
 
FunctionExp.FunctionExpFalse = 
<false>
 
FunctionExp.FunctionExpVar = 
ID
 
FunctionExp.FunctionExpIf = 
<if <FunctionExp>
then <FunctionExp> 
else <FunctionExp>
>
 
FunctionExp.FunctionExpLet = 
<let <ID> = <FunctionExp> in 
  <FunctionExp>
>
 
FunctionExp.FunctionExpApp = 
<<ID>(<{FunctionExp ","}*>)>
 
FunctionExp = 
<(<FunctionExp>)> {bracket}

FunctionExp.FunctionExpMeta = 
MetaVar 

MetaVar.Meta = 
<~<ID>> 
  
FunctionPattern.FunctionPatVar = 
ID 

FunctionPattern.FunctionPatApp = 
<<ID>(<{FunctionPattern ","}*>)>
 
FunctionExp.FunctionExpNot = 
"!"FunctionExp

FunctionExp.FunctionExpEq = 
FunctionExp "=" FunctionExp 

FunctionExp.FunctionExpEq = 
FunctionExp "==" FunctionExp
 
FunctionExp.FunctionExpNeq = 
FunctionExp "!=" FunctionExp

FunctionExp.FunctionExpAnd = 
FunctionExp "&&" FunctionExp {right}

FunctionExp.FunctionExpOr = 
FunctionExp "||" FunctionExp {right}

context-free priorities

   FunctionExp.FunctionExpNot > {non-assoc:
   FunctionExp.FunctionExpEq FunctionExp.FunctionExpNeq
     } > FunctionExp.FunctionExpAnd > FunctionExp.FunctionExpOr

context-free syntax

Import.Import = 
<import <MID>
<ImportAnnos?>

> 

ImportAnnos.ImportAnno = 
<{ <{ImportAnno ","}*> }> 
  
ImportAnno.ImportAnnoNames = 
<names>
 
ImportAnno.ImportAnnoAxioms = 
<axioms>
 
ImportAnno.ImportAnnoFunctions = 
<functions>
 
ImportAnno.ImportAnnoGoals = 
<goals>
 
ImportAnno.ImportAnnoConstructors = 
<constructors>

ModuleDef.Local = 
<local { 
  	<ModuleDef*> 
}>
 
DataTypeConstructor =
ID {ast("DataTypeConstructor(<1>, [])")}

DataTypeConstructor.DataTypeConstructor = 
<<ID> ( <{SortRef ","}*> )>
 
ModuleDef.DataType = 
<data <ID> = <{DataTypeConstructor "|"}+>>
 
ModuleDef.Sorts = 
<sorts <SortDef*>
  
> 

ModuleDef = 
<sort <SortDef>
  
> {ast("Sorts([<1>])")}

ModuleDef.Constructors = 
<constructors 
	<ConstructorDecl*>
	
>
 
ModuleDef = 
<constructor 
	<ConstructorDecl>
	
> {ast("Constructors([<1>])")}

ModuleDef.Consts = 
<consts <ConstDecl*>

>
 
ModuleDef = 
<const <ConstDecl>

> {ast("Consts([<1>])")}
  
ModuleDef.Functions = 
<functions 
<FunctionDef*>

> 

ModuleDef = <function 
<FunctionDef>

> {ast("Functions([<1>])")}

ModuleDef.PartialFunctions = 
<partial functions 
<FunctionDef*>

>
 
ModuleDef = 
<partial function 
<FunctionDef>

> {ast("PartialFunctions([<1>])")}

ModuleDef.PartialFunctions = 
<relations 
<RelationDef*>

> 

ModuleDef = 
<relation 
<RelationDef>

> {ast("PartialFunctions([<1>])")}

ModuleDef.Axioms = 
<axioms 
<TypingRule*>

>
 
ModuleDef = 
<axiom 
<TypingRule>

> {ast("Axioms([<1>])")}

ModuleDef.Goals = 
<goals 
<TypingRule*>

> 

ModuleDef = 
<goal 
<TypingRule>

> {ast("Goals([<1>])")}

ModuleDef.Lemmas = 
<lemmas 
<TypingRule*>

>
 
ModuleDef = 
<lemma 
<TypingRule>

> {ast("Lemmas([<1>])")}

ModuleDef.Include = 
<include {<{Name ","}*>}>

ModuleDef.Hide = 
<hide {<{Name ","}*>}>
  
Module.Module = 
<module <MID>
  
<Import*> 

<ModuleDef*>> 

context-free start-symbols

  Module
