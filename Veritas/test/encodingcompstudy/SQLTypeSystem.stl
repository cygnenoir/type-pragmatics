module encodingcompstudy.SQLTypeSystem

//this module contains basic utility function

//option datatype (ignoring types!) check whether this is a good idea!

sorts
	A Opt
	
constructors
	none : Opt
	some : A -> Opt
	
function
isSome : Opt -> Bool
isSome(none) = false
isSome(some(a)) = true

partial function
getSome : Opt -> A
getSome(some(a)) = a

axiom
isSome(~opt)
================= isSome-INV-1
exists ~a
	~opt = some(~a)
	getSome(~opt) = ~a

axiom
~opt = some(~a)
getSome(~opt) = ~b
================= isSome-INV-2
~a = ~b

// explanation:
// FType: type of a single field (underspecified)
// AName: name of attribute (underspecified)
// AList: list of attribute names
// CType: type of a single column (pair AName, FType)
// TType: type of a table (table schema) - list of CType


sorts
	FType AName AList CType TType RawType
	
constructors
	ctype : AName FType -> CType
	aempty : AList
	acons : AName AList -> AList
	ttempty : TType
	ttcons : CType TType -> TType
	rtempty : RawType
	rtcons : FType RawType -> RawType

//explanation:
// FVal: Value for a field (underspecified)
// Row: table row, list of field values (with at least one cell/field per construction!)
// RawTable: table matrix (list of rows), without "header" (attribute list)
// Table: full table with "header" (attribute list) 
	
sorts
	FVal Row RawTable Table 

constructors
	rempty : Row
	rcons : FVal Row -> Row
	tempty : RawTable
	tcons : Row RawTable -> RawTable
	table : AList RawTable -> Table

function
getRaw : Table -> RawTable
getRaw(table(al, rt)) = rt

function 
getAL : Table -> AList
getAL(table(al, rt)) = al

// function that assigns a field type to every field value  (underspecified)	
function
fieldType : FVal -> FType

// function that compares whether first field value is smaller than second field value 
// (underspecified)
function
le : FVal FVal -> Bool

// function that compares whether first field value is greater than second field value 
// (underspecified)
function
ge : FVal FVal -> Bool

// check whether a table corresponds to a given type (functional notation)
// does not yet check for whether the table type contains only unique attribute names!!
// (but semantics should be possible to define in a sensible way without that requirement...)
	
function 
matchingAList : TType AList -> Bool
matchingAList(ttempty, aempty) = true
matchingAList(ttcons(ctype(a1, f), tt), acons(a2, al)) = 
	(a1 == a2) && matchingAList(tt, al)
matchingAList(tt, al) = false	
	
function
welltypedtable : TType Table -> Bool
welltypedtable(tt, table(al, t)) = matchingAList(tt, al) && welltypedRawtable(rawType(tt), t)

function
rawType : TType -> RawType
rawType(ttempty) = rtempty
rawType(ttcons(ctype(a, ft), tt)) = rtcons(ft, rawType(tt))

function
welltypedRawtable : RawType RawTable -> Bool
welltypedRawtable(rt, tempty) = true
welltypedRawtable(rt, tcons(r, t)) = welltypedRow(rt, r) && welltypedRawtable(rt, t)

function
welltypedRow : RawType Row -> Bool
welltypedRow(rtempty, rempty) = true
welltypedRow(rtcons(ft, rt), rcons(v, r)) = (fieldType(v) == ft) && welltypedRow(rt, r)
welltypedRow(rt, r) = false
	
sorts
	Pred Query TRef
	
// constructors
// 	VEquals : AName FVar -> SQLPred
// 	//AEquals : AName AName -> SQLPred
// 	VGreater : AName FVar -> SQLPred
// 	//AGreater : AName AName -> SQLPred
// 	VSmaller : AName FVar -> SQLPred
// 	//ASmaller : AName AName -> SQLPred
	
	
constructors
	Ref : TName -> TRef
	
	Tvalue : Table -> Query
	Selectallfrom : TRef -> Query
	Selectsomefrom : AList TRef -> Query
	//SelectFrom2 : TType TName TName -> SQLExp
	//SelectAllFromWhere1 : TName SQLPred -> SQLExp
	//SelectFromWhere1 : TType TName SQLPred -> SQLExp
	//SelectFromWhere2 : TType TName TName SQLPred -> SQLExp
	//Union : Query Query -> Query
	//Intersection : SQLExp SQLExp -> SQLExp
	//Difference : SQLExp SQLExp -> SQLExp
	
function
isValue : Query -> Bool
isValue(Tvalue(t)) = true
isValue(Selectallfrom(n)) = false
isValue(Selectsomefrom(al, tn)) = false
//isValue(SelectFrom2(tt, tn1, tn2)) = false
// isValue(SelectAllFromWhere1(tn, p)) = false
// isValue(SelectFromWhere1(tt, tn, p)) = false
//isValue(SelectFromWhere2(tt, tn1, tn2, p)) = false
//isValue(Union(q1, q2)) = false
// isValue(Intersection(sql1, sql2)) = false
// isValue(Difference(sql1, sql2)) = false

axiom
isValue(~sql)
====================== isValue-INV
exists ~t
	~sql == Tvalue(~t)

function
dropFirstColType : TType -> TType
dropFirstColType(ttempty) = ttempty
dropFirstColtType(ttcons(ct, tt)) = tt
	
function
findColType : AName TType -> Opt // Opt[FType]
findColType(an, ttempty) = none
findColType(an, ttcons(ctype(a, ft), ttr)) =
	if (an == a)
	then some(ft)
	else findColType(an, ttr)

function
projectType : AList TType -> Opt // Opt[TType]
projectType(aempty, tt) = some(ttempty)
projectType(acons(a, alr), tt) =
	let ft = findColType(a, tt) in
		let tprest = projectType(alr, tt) in
			if (isSome(ft) && isSome(tprest))
			then some(ttcons(ctype(a, getSome(ft)), getSome(tprest)))
			else none


sorts
	OptContext
	
constructors
	cnone : OptContext
	csome : TType -> OptContext
	
function
iscSome : OptContext -> Bool
iscSome(cnone) = false
iscSome(csome(a)) = true

partial function
getcSome : OptContext -> TType
getcSome(csome(a)) = a

axiom
iscSome(~opt)
================= iscSome-INV-1
exists ~a
	~opt = csome(~a)
	getcSome(~opt) = ~a

axiom
~opt = csome(~a)
getcSome(~opt) = ~b
================= iscSome-INV-2
~a = ~b

sorts
	TTContext TName
	
constructors
	cempty : TTContext
	cbind : TName TType TTContext -> TTContext
	
function
clookup : TName TTContext -> OptContext
clookup(tn, cempty) = cnone
clookup(tn, cbind(tm, tt, TTC)) =
	if (tn == tm)
	then csome(tt)
	else clookup(tn, TTC) 
	
axioms
~x == ~y
cbind(~x, ~Tx, cbind(~y, ~Ty, ~C)) |- ~e : ~T
================================================ T-TTContext-Duplicate
cbind(~x, ~Tx, ~C) |- ~e : ~T

~x != ~y
cbind(~x, ~Tx, cbind(~y, ~Ty, ~C)) |- ~e : ~T
================================================ T-TTContext-Swap
cbind(~y, ~Ty, cbind(~x, ~Tx, ~C)) |- ~e : ~T 
 
 
axioms
//a table value with a well-typed table is typable
welltypedtable(~TT, table(~al, ~rt))
====================================== T-Tvalue
~TTC |- Tvalue(table(~al, ~rt)) : ~TT

clookup(~tn, ~TTC) == csome(~TT)
=============================================== T-Selectallfrom
~TTC |- Selectallfrom(Ref(~tn)) : ~TT

clookup(~tn, ~TTC) == csome(~TT1)
projectType(~al, ~TT1) == csome(~TT)
================================================ T-Selectsomefrom
~TTC |- Selectsomefrom(~al, Ref(~tn)) : ~TT