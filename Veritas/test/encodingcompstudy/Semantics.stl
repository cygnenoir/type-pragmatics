module encodingcompstudy.Semantics

import encodingcompstudy.Tables
import encodingcompstudy.TableAux
import encodingcompstudy.Syntax
import encodingcompstudy.TStore



data Conf = 
	conf(Query, TStore)

function
getQuery : Conf -> Query
getQuery(conf(q, ts)) = q

data OptConf =
	noConf |
	someConf(Conf)

function
isSomeConf : OptConf -> Bool
isSomeConf(noConf) = false
isSomeConf(someConf(t)) = true

partial function
getSomeConf : OptConf -> Conf
getSomeConf(someConf(c)) = c

function
findCol : Name AttrL RawTable -> OptRawTable
findCol(a, aempty, rt) = noRawTable
findCol(a, acons(a2, al), rt) = 
		if (a == a2)
		then someRawTable(projectFirstRaw(rt))
		else findCol(a, al, dropFirstColRaw(rt))

// for projection base case: projecting on an empty attribute list must yield a 
// table with as many empty rows as the rowcount of the given table
function
projectEmptyCol : RawTable -> RawTable
projectEmptyCol(tempty) = tempty
projectEmptyCol(tcons(r, t)) = tcons(rempty, projectEmptyCol(t))
	
function // select-list table-list table-rows
project : AttrL AttrL RawTable -> OptRawTable 
project(aempty, al, rt) = someRawTable(projectEmptyCol(rt))
project(acons(a, alr), al, rt) =
	let col = findCol(a, al, rt) in
		let rest = project(alr, al, rt) in
			if (isSomeRawTable(col) && isSomeRawTable(rest))
			then attachColToFrontRaw(getRawTable(col), getRawTable(rest))
			else noRawTable

function
select : Select AttrL RawTable -> OptTable
select(all(), al, rt) = someTable(table(al, rt))
select(some(alr), al, rt) =
	let projected = project(alr, al, rt) in
	if isSomeRawTable(projected)
	then someTable(table(alr, getRawTable(projected)))
	else noTable

data OptVal = noVal | someVal(Val)
data OptRow = noRow | someRow(Row)

function
isSomeVal : OptVal -> Bool
isSomeVal(noVal) = false
isSomeVal(someVal(v)) = true

partial function
getVal : OptVal -> Val
getVal(someVal(v)) = v

function
evalExpRow : Exp AttrL Row -> OptVal
evalExpRow(constant(v), al, r) = someVal(v)
evalExpRow(lookup(a), acons(a2, al), rcons(v, r)) =
	if a == a2
	then someVal(v)
	else evalExpRow(lookup(a), al, r)
evalExpRow(e, al, r) = noVal

// returns true iff predicate succeeds on row
// returns false if predicate evaluates to false or if predicate evaluation fails
function 
filterSingleRow : Pred AttrL Row -> Bool
filterSingleRow(ptrue, al, r) = 
	true
filterSingleRow(and(p1, p2), al, r) = 
	filterSingleRow(p1, al, r) && filterSingleRow(p2, al, r)
filterSingleRow(not(p), al, r) = 
	!filterSingleRow(p, al, r)
filterSingleRow(eq(e1, e2), al, r) =
	let v1 = evalExpRow(e1, al, r) in
	let v2 = evalExpRow(e2, al, r) in
	(isSomeVal(v1) && isSomeVal(v2) && (getVal(v1) == getVal(v2)))
filterSingleRow(gt(e1, e2), al, r) =
	let v1 = evalExpRow(e1, al, r) in
	let v2 = evalExpRow(e2, al, r) in
	(isSomeVal(v1) && isSomeVal(v2) && greaterThan(getVal(v1), getVal(v2)))
filterSingleRow(lt(e1, e2), al, r) =
	let v1 = evalExpRow(e1, al, r) in
	let v2 = evalExpRow(e2, al, r) in
	(isSomeVal(v1) && isSomeVal(v2) && lessThan(getVal(v1), getVal(v2)))

// filter rows that satisfy pred
function
filterRows : RawTable AttrL Pred -> RawTable
filterRows(tempty, al, pred) = tempty
filterRows(tcons(r, rt), al, pred) =
	let rts = filterRows(rt, al, pred) in
		if filterSingleRow(pred, al, r)
		then tcons(r, rts)
		else rts


// reduce fails if referenced tables are not found
function 
reduce : Conf -> OptConf
reduce(conf(tvalue(t), ts)) = noConf
reduce(conf(selectFromWhere(sel, name, pred), ts)) = 
	let maybeTable = lookupStore(name, ts) in
		if (isSomeTable(maybeTable))
		then let attrl = getAttrL(getTable(maybeTable)) in
		     let filtered = filterRows(getRaw(getTable(maybeTable)), attrl, pred) in
		     let maybeSelected = select(sel, attrl, filtered) in
			     if (isSomeTable(maybeSelected))
			     then someConf(conf(tvalue(getTable(maybeSelected)), ts))
			     else noConf
		else noConf
reduce(conf(Union(tvalue(table(al1, rt1)), tvalue(table(al2, rt2))), ts)) =
	someConf(conf(tvalue(table(al1, rawUnion(rt1, rt2))), ts))
reduce(conf(Union(tvalue(t), q2), ts)) =
	let q2reduce = reduce(conf(q2, ts)) in
		if (isSomeConf(q2reduce))
		then someConf(conf(Union(tvalue(t), getQuery(getSomeConf(q2reduce))), ts))
		else noConf
reduce(conf(Union(q1, q2), ts)) =
	let q1reduce = reduce(conf(q1, ts)) in
		if (isSomeConf(q1reduce))
		then someConf(conf(Union(getQuery(getSomeConf(q1reduce)), q2), ts))
		else noConf
reduce(conf(Intersection(tvalue(table(al1, rt1)), tvalue(table(al2, rt2))), ts)) =
	someConf(conf(tvalue(table(al1, rawIntersection(rt1, rt2))), ts))
reduce(conf(Intersection(tvalue(t), sql2), ts)) =
	let sql2reduce = reduce(conf(sql2, ts)) in
		if (isSomeConf(sql2reduce))
		then someConf(conf(Intersection(tvalue(t), getQuery(getSomeConf(sql2reduce))), ts))
		else noConf
reduce(conf(Intersection(sql1, sql2), ts)) =
	let sql1reduce = reduce(conf(sql1, ts)) in
		if (isSomeConf(sql1reduce))
		then someConf(conf(Intersection(getQuery(getSomeConf(sql1reduce)), sql2), ts))
		else noConf
reduce(conf(Difference(tvalue(table(al1, rt1)), tvalue(table(al2, rt2))), ts)) =
	someConf(conf(tvalue(table(al1, rawDifference(rt1, rt2))), ts))
reduce(conf(Difference(tvalue(t), sql2), ts)) =
	let sql2reduce = reduce(conf(sql2, ts)) in
		if (isSomeConf(sql2reduce))
		then someConf(conf(Difference(tvalue(t), getQuery(getSomeConf(sql2reduce))), ts))
		else noConf
reduce(conf(Difference(sql1, sql2), ts)) =
	let sql1reduce = reduce(conf(sql1, ts)) in
		if (isSomeConf(sql1reduce))
		then someConf(conf(Difference(getQuery(getSomeConf(sql1reduce)), sql2), ts))
		else noConf
