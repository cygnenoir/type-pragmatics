module sql.ProgressProjection

import sql.TableAux
import sql.BasicFunctions
import sql.SoundnessAuxDefs
import sql.TypeSystem
import sql.Semantics
import sql.TStore
import sql.Tables
import sql.TContext

// proof of progress-projection by induction over structure of attribute list

goal
StoreContextConsistent(~TS, ~TTC)
clookup(~tn, ~TTC) == some(~TT1)
lookup(~tn, ~TS) == some(~t)
projectType(aempty, ~TT1) == some(~TT2)
====================================== progress-projection-aempty
exists ~t2
	project(aempty, ~t) == some(~t2)

// case distinction for progress-findCol-attachColToFrontRaw	

//proof of progress-attachColToFrontRaw by induction on row-length of given column

local {
	
	
	
	local {
		// proof of findCol-emptyTable-contradiction by induction
		// on the recursive structure of findCol
		consts 
	 	a : AName
	 	a2 : AName
	 	al : AList
	 	rt : RawTable
		
		goal
		rt != tempty
		============================================== findCol-emptyTable-contradiction-1
		findCol(a, table(aempty, rt)) != some(tempty)
		
		axiom
		rt != tempty
		=========================================================== findCol-emptyTable-contradiction-2-IH
		findCol(a, table(al, dropFirstColRaw(rt))) != some(tempty)
		
		goal
		rt != tempty
		===================================================== findCol-emptyTable-contradiction-2
		findCol(a, table(acons(a2, al), rt)) != some(tempty)	
	}
	
	axiom
	~rt != tempty
	============================================== findCol-emptyTable-contradiction
	findCol(~a, table(~al, ~rt)) != some(tempty)
		
	// goal
	// welltypedtable(~TT1, table(~al, ~rt))
	// findCol(~a, table(~al, ~rt)) == some(tempty)
	// ============================================== findCol-emptyTable
	// ~rt == tempty
	// 
	// axiom
	// welltypedtable(~TT1, table(~al, ~rt))
	// findCol(~a, table(~al, ~rt)) == some(tempty)
	// ============================================== findCol-emptyTable
	// ~rt == tempty
	
	local {
		// proof of project-emptyTable by induction on length of argument list (aempty/acons)
		const alr : AList
		
		goal
		project(aempty, table(~al, tempty)) == some(~rt2)	
		=============================================== project-emptyTable-aempty
		~rt2 == tempty
		
		axiom
		project(alr, table(~al, tempty)) == some(~rt2)	
		=============================================== project-emptyTable-acons-IH
		~rt2 == tempty
		
		goal
		project(acons(~a, alr), table(~al, tempty)) == some(~rt2)	
		========================================================= project-emptyTable-acons
		~rt2 == tempty
	
	}
	
	axiom
	project(~ar, table(~al, tempty)) == some(~rt2)	
	============================================== project-emptyTable
	~rt2 == tempty
	
	
	goal
	welltypedtable(~TT1, ~t)
	findCol(~a, ~t) == some(tempty)
	project(~ar, ~t) == some(~rt2)	
	================================================= progress-attachColToFrontRaw-tempty
	exists ~rt3
		attachColToFrontRaw(tempty, ~rt2) == some(~rt3)
}
	
local {
	const rt1 : RawTable
	
	// goal //TODO prove
	// welltypedtable(~TT1, ~t)
	// projectType(acons(~a, ~ar), ~TT1) == some(~TT2)
	// findCol(~a, ~t) == some(tcons(~r1, ~rt1))
	// =================================================== findCol-tcons-project-tcons
	// exists ~f, ~r2, ~rt2
	// 	~r1 == rcons(~f, rempty)
	// 	project(~ar, ~t) == some(tcons(~r2, ~rt2))
	
	axiom //TODO prove
	welltypedtable(~TT1, ~t)
	findCol(~a, ~t) == some(tcons(~r1, ~rt1))
	=================================================== findCol-tcons-project-tcons
	exists ~f, ~r2, ~rt2
		~r1 == rcons(~f, rempty)
		project(~ar, ~t) == some(tcons(~r2, ~rt2))
	
	axiom 
	welltypedtable(~TT1, ~t)
	findCol(~a, ~t) == some(rt1)
	project(~ar, ~t) == some(~rt2)
	================================================= progress-attachColToFrontRaw-tcons-IH
	exists ~rt3
		attachColToFrontRaw(rt1, ~rt2) == some(~rt3)
		
	goal
	welltypedtable(~TT1, ~t)
	findCol(~a, ~t) == some(tcons(~r1, rt1))
	project(~ar, ~t) == some(~rt2)
	================================================= progress-attachColToFrontRaw-tcons
	exists ~rt3
		attachColToFrontRaw(tcons(~r1, rt1), ~rt2) == some(~rt3)
	
}

axiom 
welltypedtable(~TT1, ~t)
findCol(~a, ~t) == some(~crt)
project(~ar, ~t) == some(~rt)
================================================= progress-attachColToFrontRaw
exists ~rt2
	attachColToFrontRaw(~crt, ~rt) == some(~rt2) 
	
	
//proof of progress-findCol by induction on the recursive structure of findCol
		
local {
	
	//trivial base case, premises cannot both be true
	goal
	welltypedtable(~TT1, table(aempty, ~rt))
	projectType(acons(~a, ~ar), ~TT1) == some(~TT2)
	=============================================== progress-findCol-1
	exists ~c
		findCol(~a, table(aempty, ~rt)) == some(~c)

	//auxiliary lemmas for induction step case
	goal 
	welltypedtable(~TT1, table(acons(~a, ~al), ~rt))
	=================================================== welltypedtable-type
	exists ~ft, ~TTR
		~TT1 == ttcons(ctype(~a, ~ft), ~TTR)
	
	axiom 
	welltypedtable(~TT1, table(acons(~a, ~al), ~rt))
	=================================================== welltypedtable-type
	exists ~ft, ~TTR
		~TT1 == ttcons(ctype(~a, ~ft), ~TTR)
	
	
	local {
		axiom //Proof in PreservationProjection.stl  
		welltypedRawtable(rtcons(~ft, ~RT), ~rt)
		===================================================== DropFirstCol-Preservation
		welltypedRawtable(~RT, dropFirstColRaw(~rt))
	
		goal
		welltypedtable(ttcons(ctype(~a, ~ft), ~TTR), table(acons(~a, ~al), ~rt))
		========================================================================== welltyped-subtable
		exists ~rt2
			welltypedtable(~TTR, table(~al, dropFirstColRaw(~rt)))
	}
	
	axiom
	welltypedtable(ttcons(ctype(~a, ~ft), ~TTR), table(acons(~a, ~al), ~rt))
	========================================================================== welltyped-subtable
	welltypedtable(~TTR, table(~al, dropFirstColRaw(~rt)))
	
	
	consts 
	 a : AName
	 a2 : AName
	 al : AList
	 rt : RawTable

	axiom
	welltypedtable(~TTR, table(al, dropFirstColRaw(rt)))
	findColType(a, ~TTR) == some(~TTR2)
	============================================================ progress-findCol-2-IH
	exists ~c
		findCol(a, table(al, dropFirstColRaw(rt))) == some(~c)
		
	goal
	welltypedtable(~TT1, table(acons(a2, al), rt))
	findColType(a, ~TT1) == some(~TT2)
	==================================================== progress-2-acons
	exists ~c
		findCol(a, table(acons(a2, al), rt)) == some(~c)

} //qed progress-findCol
		
axiom
welltypedtable(~TT1, ~t)	
findColType(~a, ~TT1) == some(~TT2)
=============================================== progress-findCol
exists ~c
	findCol(~a, ~t) == some(~c)
	
//pull progress-attachColToFrontRow and progress-findCol together 
//- Vampire seems to need that additional step
//using findColType instead of projectType also doesn't work for the intermediate step	
goal
welltypedtable(~TT1, ~t)
projectType(acons(~a, ~ar), ~TT1) == some(~TT2)
project(~ar, ~t) == some(~rt)
===================================================== progress-findCol-attachColToFrontRaw
exists ~crt, ~rt2
 	findCol(~a, ~t) == some(~crt)
 	attachColToFrontRaw(~crt, ~rt) == some(~rt2)
 	
//qed case distinction for progress-findCol-attachColToFrontRaw
	
local {
	const ar : AList
	
	// pulled axiom inside local block, made meta-variable ~ar a constant
	axiom
	welltypedtable(~TT1, ~t)
	projectType(acons(~a, ar), ~TT1) == some(~TT2)
	project(ar, ~t) == some(~rt)
	===================================================== progress-findCol-attachColToFrontRaw
	exists ~crt, ~rt2
		findCol(~a, ~t) == some(~crt)
 		attachColToFrontRaw(~crt, ~rt) == some(~rt2) 
		
	axiom
	StoreContextConsistent(~TS, ~TTC)
	clookup(~tn, ~TTC) == some(~TT1)
	lookup(~tn, ~TS) == some(~t)
	projectType(ar, ~TT1) == some(~TT2)
	====================================== progress-projection-acons-IH
	exists ~rt
		project(ar, ~t) == some(~rt)
		
	goal
	StoreContextConsistent(~TS, ~TTC)
	clookup(~tn, ~TTC) == some(~TT1)
	lookup(~tn, ~TS) == some(~t)
	projectType(acons(~a, ar), ~TT1) == some(~TT2)
	=============================================== progress-projection-acons
	exists ~t2
		project(acons(~a, ar), ~t) == some(~t2)
} //qed progress-projection


axiom
StoreContextConsistent(~TS, ~TTC)
clookup(~tn, ~TTC) == some(~TT1)
lookup(~tn, ~TS) == some(~t)
projectType(~al, ~TT1) == some(~TT2)
====================================== progress-projection
exists ~t2
	project(~al, ~t) == some(~t2)
