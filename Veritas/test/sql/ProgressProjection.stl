module sql.ProgressProjection

import sql.TableAux
import sql.BasicFunctions
import sql.SoundnessAuxDefs
import sql.TypeSystem
import sql.Semantics
import sql.TStore
import sql.Tables
import sql.TContext

// case distinction for progress-findCol-attachColToFrontRaw	

//proof of progress-attachColToFrontRaw by induction on 
// the recursive structure of attachColToFrontRaw

	// local {
	// 	//proof of findCol-emptyTable by induction
	// 	//on the recursive structure of findCol
	// 	
	// 	consts 
	//  		a : AName
	//  		a2 : AName
	//  		al : AList
	//  		rt : RawTable
	//  		
	//  	goal
	// 	findCol(a, table(aempty, rt)) == some(tempty)
	// 	============================================== findCol-emptyTable-1
	// 	rt == tempty
	// 	
	// 	axiom
	// 	findCol(a, table(al, dropFirstColRaw(rt))) == some(tempty)
	// 	=========================================================== findCol-emptyTable-IH
	// 	rt == tempty
	// 	
	// 	goal
	// 	findCol(a, table(acons(a2, al), rt)) == some(tempty)
	// 	==================================================== findCol-emptyTable-2
	// 	rt == tempty
	// 	
	// axiom
	// findCol(~a, table(~al, ~rt)) == some(tempty)
	// ============================================== findCol-emptyTable
	// ~rt == tempty
	// }
	// 
	// 	local {
	// 	// proof of project-emptyTable by induction on length of argument list (aempty/acons)
	// 	const alr : AList
	// 	
	// 	goal
	// 	project(aempty, table(~al, tempty)) == some(~rt2)	
	// 	=============================================== project-emptyTable-aempty
	// 	~rt2 == tempty
	// 	
	// 	axiom
	// 	project(alr, table(~al, tempty)) == some(~rt2)	
	// 	=============================================== project-emptyTable-acons-IH
	// 	~rt2 == tempty
	// 	
	// 	goal
	// 	project(acons(~a, alr), table(~al, tempty)) == some(~rt2)	
	// 	========================================================= project-emptyTable-acons
	// 	~rt2 == tempty
	// 	
	// axiom
	// project(~ar, table(~al, tempty)) == some(~rt2)	
	// ============================================== project-emptyTable
	// ~rt2 == tempty
	// 
	// }

local {	

	// trivial base case
	goal
	welltypedtable(~TT1, ~t)
	findCol(~a, ~t) == some(tempty)
	project(~ar, ~t) == some(tempty)	
	================================================= progress-attachColToFrontRaw-1
	exists ~rt3
		attachColToFrontRaw(tempty, tempty) == some(~rt3)
		
		
	// induction step 
	consts
		f : FVal
		rt1 : RawTable
		r : Row
		rt2 : RawTable
		
		
	// axiom //TODO prove
	// findCol(~a, table(~al, ~rt)) == some(tcons(~r1, ~rt1))
	// ========================================================= findCol-nonemptyTable
	// exists ~r2, ~rt2
	// 	~rt == tcons(~r2, ~rt2)
		
	// axiom //TODO prove
	// welltypedtable(~TT1, tcons(~r, ~rt))
	// ====================================== welltyped-minus-first-Row
	// welltypedtable(~TT1, ~rt)
	// 
	// axiom //TODO prove
	// findCol(~a, tcons(~r, ~rt)) == some(tcons(~r1, ~rt1))
	// ===================================================== findCol-minus-first-Row
	// findCol(~a, ~rt) == some(~rt1)
	// 
	// axiom //TODO prove
	// project(~ar, tcons(~r, ~rt)) == some(tcons(~r1, ~rt1))
	// ======================================================= project-minus-first-Row
	// project(~ar, ~rt) == some(~rt1)
	
	axiom //TODO prove
	welltypedtable(~TT1, ~t)
	findCol(~a, ~t) == some(tcons(rcons(f, rempty), rt1))
	project(~ar, ~t) == some(tcons(~r1, rt2))
	====================================================== table-minus-first-Row
	exists ~al, ~r, ~rt
		~t == table(~al, tcons(~r, ~rt))
		welltypedtable(~TT1, ~rt)
		findCol(~a, ~rt) == some(rt1)
		project(~ar, ~rt) == some(rt2)
	
	axiom 
	welltypedtable(~TT1, ~t)
	findCol(~a, ~t) == some(rt1)
	project(~ar, ~t) == some(rt2)
	================================================= progress-attachColToFrontRaw-2-IH
	exists ~rt3
		attachColToFrontRaw(rt1, rt2) == some(~rt3)
		
	goal
	welltypedtable(~TT1, ~t)
	findCol(~a, ~t) == some(tcons(rcons(f, rempty), rt1))
	project(~ar, ~t) == some(tcons(r, rt2))
	=================================================================================== progress-attachColToFrontRaw-2
	exists ~rt3
		attachColToFrontRaw(tcons(rcons(f, rempty), rt1), tcons(r, rt2)) == some(~rt3)
		
		
	// non-trivial base case, confirming that the first two cases are the only ones that can happen
	axiom // TODO prove
	welltypedtable(~TT1, ~t)
	findCol(~a, ~t) == some(~rt1)
	project(~ar, ~t) == some(~rt2)
	~rt1 == tempty
	================================= project-find-Col-equal-length-tempty-1
	~rt2 == tempty
	
	axiom // TODO prove
	welltypedtable(~TT1, ~t)
	findCol(~a, ~t) == some(~rt1)
	project(~ar, ~t) == some(~rt2)
	~rt2 == tempty
	================================= project-find-Col-equal-length-tempty-2
	~rt1 == tempty
	
	axiom // TODO prove
	welltypedtable(~TT1, ~t)
	findCol(~a, ~t) == some(~rt1)
	project(~ar, ~t) == some(~rt2)
	~rt1 == tcons(rcons(~f, rempty), ~rt1)
	========================================= project-find-Col-equal-length-tcons-1
	exists ~r3, ~rt3
		~rt2 == rcons(~r3, ~rt3) 
		
	axiom // TODO prove
	welltypedtable(~TT1, ~t)
	findCol(~a, ~t) == some(~rt1)
	project(~ar, ~t) == some(~rt2)
	~rt2 == rcons(~r3, ~rt3) 
	============================================ project-find-Col-equal-length-tcons-2
	exists ~f, ~rt1
		~rt1 == tcons(rcons(~f, rempty), ~rt1)
		
	axiom
	OR
	=> ~rt1 != tempty
	=> ~rt2 != tempty
	welltypedtable(~TT1, ~t)
	findCol(~a, ~t) == some(~rt1)
	project(~ar, ~t) == some(~rt2)
	======================================== progress-attachColToFrontRaw-aux-1
	false
	
	axiom
	OR 
	=> forall ~r, ~rt ~rt1 != tcons(rcons(~f, rempty), ~rt)
	=> forall ~r, ~rt3 ~rt2 != tcons(~r, ~rt3)
	welltypedtable(~TT1, ~t)
	findCol(~a, ~t) == some(~rt1)
	project(~ar, ~t) == some(~rt2)
	======================================================= progress-attachColToFrontRaw-aux-2
	false
	
	
	goal
	OR
	=> ~rt1 != tempty
	=> ~rt2 != tempty
	OR 
	=> forall ~r, ~rt ~rt1 != tcons(rcons(~f, rempty), ~rt)
	=> forall ~r, ~rt3 ~rt2 != tcons(~r, ~rt3)
	welltypedtable(~TT1, ~t)
	findCol(~a, ~t) == some(~rt1)
	project(~ar, ~t) == some(~rt2)
	=================================================================================== progress-attachColToFrontRaw-3
	exists ~rt3 
		attachColToFrontRaw(~rt1, ~rt2) == some(~rt3)	
		
}
	
// local {
// 	const rt1 : RawTable
// 	
// 	// welltypedtable premise is necessary here, because findCol can indeed yield the empty column
// 	// as result for a table with a non-empty attribute list, but with only one empty column as content
// 	// (but such a table would not be well-typed!)
// 	
// 		
// 	axiom //TODO prove
// 	project(~ar, table(~al, tcons(~r, ~rt))) == some(~rt1)	
// 	======================================================== project-nonemptyTable
// 	exists ~r2, ~rt2
// 		~rt1 == tcons(~r2, ~rt2)
// }

axiom 
welltypedtable(~TT1, ~t)
findCol(~a, ~t) == some(~crt)
project(~ar, ~t) == some(~rt)
================================================= progress-attachColToFrontRaw
exists ~rt2
	attachColToFrontRaw(~crt, ~rt) == some(~rt2) 
	
	
//proof of progress-findCol by induction on the recursive structure of findCol
		
local {
	
	//trivial base case, premises cannot both be true
	goal
	welltypedtable(~TT1, table(aempty, ~rt))
	projectType(acons(~a, ~ar), ~TT1) == some(~TT2)
	=============================================== progress-findCol-1
	exists ~c
		findCol(~a, table(aempty, ~rt)) == some(~c)

	//auxiliary lemmas for induction step case
	goal 
	welltypedtable(~TT1, table(acons(~a, ~al), ~rt))
	=================================================== welltypedtable-type
	exists ~ft, ~TTR
		~TT1 == ttcons(ctype(~a, ~ft), ~TTR)
	
	axiom 
	welltypedtable(~TT1, table(acons(~a, ~al), ~rt))
	=================================================== welltypedtable-type
	exists ~ft, ~TTR
		~TT1 == ttcons(ctype(~a, ~ft), ~TTR)
	
	
	local {
		axiom //Proof in PreservationProjection.stl  
		welltypedRawtable(rtcons(~ft, ~RT), ~rt)
		===================================================== DropFirstCol-Preservation
		welltypedRawtable(~RT, dropFirstColRaw(~rt))
	
		goal
		welltypedtable(ttcons(ctype(~a, ~ft), ~TTR), table(acons(~a, ~al), ~rt))
		========================================================================== welltyped-subtable
		exists ~rt2
			welltypedtable(~TTR, table(~al, dropFirstColRaw(~rt)))
	}
	
	axiom
	welltypedtable(ttcons(ctype(~a, ~ft), ~TTR), table(acons(~a, ~al), ~rt))
	========================================================================== welltyped-subtable
	welltypedtable(~TTR, table(~al, dropFirstColRaw(~rt)))
	
	
	consts 
	 a : AName
	 a2 : AName
	 al : AList
	 rt : RawTable

	axiom
	welltypedtable(~TTR, table(al, dropFirstColRaw(rt)))
	findColType(a, ~TTR) == some(~TTR2)
	============================================================ progress-findCol-2-IH
	exists ~c
		findCol(a, table(al, dropFirstColRaw(rt))) == some(~c)
		
	goal
	welltypedtable(~TT1, table(acons(a2, al), rt))
	findColType(a, ~TT1) == some(~TT2)
	==================================================== progress-2-acons
	exists ~c
		findCol(a, table(acons(a2, al), rt)) == some(~c)

} //qed progress-findCol
		
axiom
welltypedtable(~TT1, ~t)	
findColType(~a, ~TT1) == some(~TT2)
=============================================== progress-findCol
exists ~c
	findCol(~a, ~t) == some(~c)
	

	
//pull progress-attachColToFrontRow and progress-findCol together 
//- Vampire seems to need that additional step
//using findColType instead of projectType also doesn't work for the intermediate step	
goal
welltypedtable(~TT1, ~t)
projectType(acons(~a, ~ar), ~TT1) == some(~TT2)
project(~ar, ~t) == some(~rt)
===================================================== progress-findCol-attachColToFrontRaw
exists ~crt, ~rt2
 	findCol(~a, ~t) == some(~crt)
 	attachColToFrontRaw(~crt, ~rt) == some(~rt2) 
 
//qed case distinction for progress-findCol-attachColToFrontRaw
	
strategy induction-progress-projection {
	const ar : AList
	
	// proof of progress-projection by induction over structure of attribute list
	goal
	StoreContextConsistent(~TS, ~TTC)
	clookup(~tn, ~TTC) == some(~TT1)
	lookup(~tn, ~TS) == some(~t)
	projectType(aempty, ~TT1) == some(~TT2)
	====================================== progress-projection-aempty
	exists ~t2
		project(aempty, ~t) == some(~t2)

	local {
		// pulled axiom inside local block, made meta-variable ~ar a constant
		axiom
		welltypedtable(~TT1, ~t)
		projectType(acons(~a, ar), ~TT1) == some(~TT2)
		project(ar, ~t) == some(~rt)
		===================================================== progress-findCol-attachColToFrontRaw
		exists ~crt, ~rt2
			findCol(~a, ~t) == some(~crt)
 			attachColToFrontRaw(~crt, ~rt) == some(~rt2) 
		
		hide-all
		
		axiom
		StoreContextConsistent(~TS, ~TTC)
		clookup(~tn, ~TTC) == some(~TT1)
		lookup(~tn, ~TS) == some(~t)
		projectType(ar, ~TT1) == some(~TT2)
		====================================== progress-projection-acons-IH
		exists ~rt
			project(ar, ~t) == some(~rt)	
			
		include {progress-findCol-attachColToFrontRaw, 
		isSome-INV-2, isSome1, 
		progress-findCol, projectType2, DIFF-none-some, isSome-INV-1, 
		StoreContext-Lookup-WT, project1}
		
		goal
		StoreContextConsistent(~TS, ~TTC)
		clookup(~tn, ~TTC) == some(~TT1)
		lookup(~tn, ~TS) == some(~t)
		projectType(acons(~a, ar), ~TT1) == some(~TT2)
		=============================================== progress-projection-acons
		exists ~t2
			project(acons(~a, ar), ~t) == some(~rt)
	}
		
	// Verification succeeded, used lemmas: progress-findCol-attachColToFrontRaw, isSome-INV-2, progress-
 // projection-acons-IH, isSome1, progress-findCol, projectType2, DIFF-none-some, isSome-INV-1, StoreContext-
 // Lookup-WT, project1.	
 	
 	hide-all
 	axiom
	StoreContextConsistent(~TS, ~TTC)
	clookup(~tn, ~TTC) == some(~TT1)
	lookup(~tn, ~TS) == some(~t)
	projectType(~al, ~TT1) == some(~TT2)
	====================================== progress-projection-ind
	exists ~t2
		project(~al, ~t) == some(~rt)
 
} //qed progress-projection


lemma verify-with induction-progress-projection
StoreContextConsistent(~TS, ~TTC)
clookup(~tn, ~TTC) == some(~TT1)
lookup(~tn, ~TS) == some(~t)
projectType(~al, ~TT1) == some(~TT2)
====================================== progress-projection
exists ~t2
	project(~al, ~t) == some(~rt)
