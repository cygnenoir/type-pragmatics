module sql.Semantics

import sql.BasicFunctions
import sql.Syntax
import sql.TStore
import sql.Tables
import sql.TableAux

sorts
	SQLConf

constructors
	conf : SQLExp TStore -> SQLConf
	
function
getSQL : SQLConf -> SQLExp
getSQL(conf(sql, ts)) = sql
	
// function is undefined if attribute(s) to be projected on cannot be found (noTable)!
// (even if the table is empty!)
partial function
projection : TType Table -> Table
projection(ttone(ctype(a1, ft1)), table(ttone(ctype(a2, ft2)), rt)) =
	if ((a1 == a2) && (ft1 == ft2))
	then table(ttone(ctype(a1, ft1)), rt)
	else undefined
projection(ttone(ctype(a1, ft1)), table(ttmany(ctype(a2, ft2), tt), rt)) =
	if ((a1 == a2) && (ft1 == ft2))
	then table(ttone(ctype(a1, ft1)), projectFirstRaw(rt))
	else projection(ttone(ctype(a1, ft1)), table(tt, dropFirstColRaw(rt)))
projection(ttmany(ct1, tt1), table(tt, rt)) =
	table(ttmany(ct1, tt1), 
		attachColToFrontRaw(getRaw(projection(ttone(ct1), table(tt, rt))), 
			getRaw(projection(tt1, table(tt, rt)))))


// is undefined if attribute - field type pair is not in table!
partial function 
singleRowSelection : TType SQLPred RVar -> Bool
singleRowSelection(ttone(ctype(a1, ft)), VEquals(a2, fv), rone(f)) =
	if ((a1 == a2) && (fieldType(fv) == ft))
	then (f == fv)
	else undefined
singleRowSelection(ttmany(ctype(a1, ft), ttr), VEquals(a2, fv), rmany(f, r)) =
	if ((a1 == a2) && (fieldType(fv) == ft))
	then (f == fv)
	else singleRowSelection(ttr, VEquals(a2, fv), r)
singleRowSelection(ttone(ctype(a1, ft)), VGreater(a2, fv), rone(f)) =
	if ((a1 == a2) && (fieldType(fv) == ft))
	then ge(f,fv)
	else undefined
singleRowSelection(ttmany(ctype(a1, ft), ttr), VGreater(a2, fv), rmany(f, r)) =
	if ((a1 == a2) && (fieldType(fv) == ft))
	then ge(f,fv)
	else singleRowSelection(ttr, VGreater(a2, fv), r)
singleRowSelection(ttone(ctype(a1, ft)), VSmaller(a2, fv), rone(f)) =
	if ((a1 == a2) && (fieldType(fv) == ft))
	then le(f,fv)
	else undefined
singleRowSelection(ttmany(ctype(a1, ft), ttr), VSmaller(a2, fv), rmany(f, r)) =
	if ((a1 == a2) && (fieldType(fv) == ft))
	then le(f,fv)
	else singleRowSelection(ttr, VSmaller(a2, fv), r)

// top-level function for selection
partial function
selection : Table SQLPred -> Table
selection(table(tt, tempty), pred) = 
	if (checkPValidity(pred, tt))
	then table(tt, tempty)
	else undefined
selection(table(tt, tmany(r, rt)), pred) =
	let rts = selection(table(tt, rt), pred) in
		if (singleRowSelection(tt, pred, r))
		then table(tt, tmany(r, getRaw(rts)))
		else rts


// definition: union removes duplicate rows
// (but only between the two tables, not within a table!)
// union only possible if schemas of tables are exactly equal (including column order!)
// (otherwise undefined)
partial function
union : Table Table -> Table
union(table(tt1, rt1), table(tt2, rt2)) =
	if (tt1 == tt2)
	then table(tt1, rawUnion(rt1, rt2))
	else undefined

// intersection only possible if schemas of tables are exactly equal (including column order!)
// (otherwise undefined)
partial function
intersection : Table Table -> Table
intersection(table(tt1, rt1), table(tt2, rt2)) =
	if (tt1 == tt2)
	then table(tt1, rawIntersection(rt1, rt2))
	else undefined

// difference only possible if schemas of tables are exactly equal (including column order!)
// (otherwise undefined)
partial function
difference : Table Table -> Table
difference(table(tt1, rt1), table(tt2, rt2)) =
	if (tt1 == tt2)
	then table(tt1, rawDifference(rt1, rt2))
	else undefined

// reduce fails if referenced tables are not found
// gets stuck if helper functions do not yield any result
function 
reduce : SQLConf -> Opt
reduce(conf(TValue(t), ts)) = none
reduce(conf(SelectAll(tn), ts)) = 
	let ltn = lookup(tn, ts) in
		if (isSome(ltn))
		then some(conf(TValue(getSome(ltn)),ts))
		else none
reduce(conf(SelectFrom1(tt, tn), ts)) =
	let ltn = lookup(tn, ts) in
		if (isSome(ltn))
		then some(conf(TValue(projection(tt, getSome(ltn))), ts))
		else none
reduce(conf(SelectAllFromWhere1(tn, p), ts)) =
	let ltn = lookup(tn, ts) in
		if (isSome(ltn))
		then some(conf(TValue(selection(getSome(ltn), p)), ts))
		else none
reduce(conf(SelectFromWhere1(tt, tn, p), ts)) =
	let ltn = lookup(tn, ts) in
		if (isSome(ltn))
		then some(conf(TValue(projection(tt, selection(getSome(ltn), p))), ts))
		else none
reduce(conf(Union(TValue(t1), TValue(t2)), ts)) =
	some(conf(TValue(union(t1, t2)), ts))
reduce(conf(Union(TValue(t), sql2), ts)) =
	let sql2reduce = reduce(conf(sql2, ts)) in
		if (isSome(sql2reduce))
		then some(conf(Union(TValue(t), getSQL(getSome(sql2reduce))), ts))
		else none
reduce(conf(Union(sql1, sql2), ts)) =
	let sql1reduce = reduce(conf(sql1, ts)) in
		if (isSome(sql1reduce))
		then some(conf(Union(getSQL(getSome(sql1reduce)), sql2), ts))
		else none
reduce(conf(Intersection(TValue(t1), TValue(t2)), ts)) =
	some(conf(TValue(intersection(t1, t2)), ts))
reduce(conf(Intersection(TValue(t), sql2), ts)) =
	let sql2reduce = reduce(conf(sql2, ts)) in
		if (isSome(sql2reduce))
		then some(conf(Intersection(TValue(t), getSQL(getSome(sql2reduce))), ts))
		else none
reduce(conf(Intersection(sql1, sql2), ts)) =
	let sql1reduce = reduce(conf(sql1, ts)) in
		if (isSome(sql1reduce))
		then some(conf(Intersection(getSQL(getSome(sql1reduce)), sql2), ts))
		else none
reduce(conf(Difference(TValue(t1), TValue(t2)), ts)) =
	some(conf(TValue(difference(t1, t2)), ts))
reduce(conf(Difference(TValue(t), sql2), ts)) =
	let sql2reduce = reduce(conf(sql2, ts)) in
		if (isSome(sql2reduce))
		then some(conf(Difference(TValue(t), getSQL(getSome(sql2reduce))), ts))
		else none
reduce(conf(Difference(sql1, sql2), ts)) =
	let sql1reduce = reduce(conf(sql1, ts)) in
		if (isSome(sql1reduce))
		then some(conf(Difference(getSQL(getSome(sql1reduce)), sql2), ts))
		else none
	