module sql.TypeSystemInv

import sql.BasicFunctions
import sql.Syntax
import sql.TypeSystem
import sql.Tables
import sql.TContext

axiom
~TTC |- ~q : ~TT
==================================================== T-inv
OR
=> exists ~al, ~rt
		~q = Tvalue(table(~al, ~rt))
		welltypedtable(~TT, table(~al, ~rt))
=> exists ~tn
		~q == Selectallfrom(Ref(~tn))
		clookup(~tn, ~TTC) == some(~TT)
=> exists ~tn, ~TT1, ~al
		~q == Selectsomefrom(~al, Ref(~tn))
		clookup(~tn, ~TTC) == some(~TT1)
		projectType(~al, ~TT1) == some(~TT)	
// => exists ~tn, ~p, ~rt
// 		~sql == SelectAllFromWhere1(~tn, ~p)
// 		lookup(~tn, ~TS) == some(table(~TT, ~rt))
// 		welltypedtable(table(~TT, ~rt))
// 		checkPValidity(~p, ~TT)	
// => exists ~tn, ~p, ~TT1, ~rt
// 		~sql == SelectFromWhere1(~TT, ~tn, ~p)
// 		lookup(~tn, ~TS) == some(table(~TT1, ~rt))
// 		welltypedtable(table(~TT1, ~rt))
// 		checkPValidity(~p, ~TT1)
// 		typePartOf(~TT, ~TT1)
// => exists ~q1, ~q2
// 		~q == Union(~q1, ~q2)
// 		~TTC |- ~q1 : ~TT
// 		~TTC |- ~q2 : ~TT
// => exists ~sql1, ~sql2
// 		~sql == Intersection(~sql1, ~sql2)
// 		~TS |- ~sql1 : ~TT
// 		~TS |- ~sql2 : ~TT
// => exists ~sql1, ~sql2
// 		~sql == Difference(~sql1, ~sql2)
// 		~TS |- ~sql1 : ~TT
// 		~TS |- ~sql2 : ~TT
		
//variant of inversion lemma in several different lemmas 
//(seems to be helpful for progress proof)
lemma
~q == Tvalue(table(~al, ~rt))
~TTC |- ~q : ~TT
==================================================== T-inv-Tvalue
welltypedtable(~TT, table(~al, ~rt))


lemma
~q == Selectallfrom(Ref(~tn))		
~TTC |- ~q : ~TT
==================================================== T-inv-Selectallfrom		
clookup(~tn, ~TTC) == some(~TT)


lemma
~q == Selectsomefrom(~al, Ref(~tn))
~TTC |- ~q : ~TT
==================================================== T-inv-Selectsomefrom
exists ~TT1
	clookup(~tn, ~TTC) == some(~TT1)
	projectType(~al, ~TT1) == some(~TT)	
	
		
// ~sql == SelectAllFromWhere1(~tn, ~p)
// ~TS |- ~sql : ~TT
// ==================================================== T-inv-SelectAllFromWhere1
// exists ~rt
// 	lookup(~tn, ~TS) == some(table(~TT, ~rt))
// 	welltypedtable(table(~TT, ~rt))
// 	checkPValidity(~p, ~TT)	
// 		
// ~sql == SelectFromWhere1(~TT, ~tn, ~p)
// ~TS |- ~sql : ~TT
// ==================================================== T-inv-SelectFromWhere1
// exists ~rt, ~TT1
// 	lookup(~tn, ~TS) == some(table(~TT1, ~rt))
// 	welltypedtable(table(~TT1, ~rt))
// 	checkPValidity(~p, ~TT1)
// 	typePartOf(~TT, ~TT1)
// 		

// goal
// ~q == Union(~q1, ~q2)
// ~TTC |- ~q : ~TT
// ==================================================== T-inv-Union		
// ~TTC |- ~q1 : ~TT
// ~TTC |- ~q2 : ~TT
// 
// axiom
// ~q == Union(~q1, ~q2)
// ~TTC |- ~q : ~TT
// ==================================================== T-inv-Union		
// ~TTC |- ~q1 : ~TT
// ~TTC |- ~q2 : ~TT

// 
// ~sql == Intersection(~sql1, ~sql2)
// ~TS |- ~sql : ~TT
// ==================================================== T-inv-Intersection
// ~TS |- ~sql1 : ~TT
// ~TS |- ~sql2 : ~TT
// 
// ~sql == Difference(~sql1, ~sql2)
// ~TS |- ~sql : ~TT
// ==================================================== T-inv-Difference
// ~TS |- ~sql1 : ~TT
// ~TS |- ~sql2 : ~TT