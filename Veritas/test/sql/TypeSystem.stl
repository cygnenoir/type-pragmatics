module sql.TypeSystem

import sql.BasicFunctions
import sql.Tables
import sql.TStore
import sql.Syntax

sorts
	TTContext
	
constructors
	cempty : TTContext
	cbind : TName TType TTContext -> TTContext
	
function
clookup : TName TTContext -> Opt
clookup(tn, cempty) = none
clookup(tn, cbind(tm, tt, TTC)) =
	if (tn == tm)
	then some(tt)
	else lookup(tn, TTC) 
	
axioms
~x == ~y
cbind(~x, ~Tx, cbind(~y, ~Ty, ~C)) |- ~e : ~T
================================================ T-TTContext-Duplicate
cbind(~x, ~Tx, ~C) |- ~e : ~T

~x != ~y
cbind(~x, ~Tx, cbind(~y, ~Ty, ~C)) |- ~e : ~T
================================================ T-TTContext-Swap
cbind(~y, ~Ty, cbind(~x, ~Tx, ~C)) |- ~e : ~T

	
// return an optional FType
function
coltype : AName TType -> Opt
coltype(an, ttone(ctype(a, ft))) = 
	if (an == a)
	then some(ft)
	else none
coltype(an, ttmany(ctype(a, ft), ttr)) =
	if (an == a)
	then some(ft)
	else coltype(an, ttr)

// return an optional TType
function
typePart : AList TType -> Opt
typePart(aone(a1), tt) = 
	let ft = coltype(a1, tt) in
		if (isSome(ft))
		then some(ttone(ctype(a1, getSome(ft))))
		else none
typePart(amany(a1, alr), tt) =
	let ft = coltype(a1, tt) in
		let tprest = typePart(alr, tt) in
			if (isSome(ft) && isSome(tprest))
			then some(ttmany(ctype(a1, getSome(ft)), getSome(tprest)))
			else none
	
// function for typing a single table
// TODO: HOW TO TYPE A TABLE WITH NO ROWS??
// (for table with at least one row: take type of first row)
function
typetable : Table -> TType

// We assume that the FIRST binding in the given TTContext represents the 
axioms
//a table value with a well-typed table is typable
typetable(table(~al, ~rt)) == ~TT
====================================== T-TValue
~TTC |- TValue(table(~al, ~rt)) : ~TT

clookup(~tn, ~TTC) == some(~TT)
=============================================== T-SelectAll
~TTC |- SelectAll(~tn) : ~TT

clookup(~tn, ~TTC) == some(~TT1)
typePart(~al, ~TT1) == ~TT
================================================ T-SelectFrom1
~TTC |- SelectFrom1(~al, ~tn) : ~TT

// lookup(~tn, ~TS) == some(table(~TT, ~rt))
// welltypedtable(table(~TT, ~rt))
// checkPValidity(~p, ~TT)
// ================================================ T-SelectAllFromWhere1
// ~TS |- SelectAllFromWhere1(~tn, ~p) : ~TT
// 
// lookup(~tn, ~TS) == some(table(~TT1, ~rt))
// welltypedtable(table(~TT1, ~rt))
// checkPValidity(~p, ~TT1)
// typePartOf(~TT, ~TT1)
// ================================================ T-SelectFromWhere1
// ~TS |- SelectFromWhere1(~TT, ~tn, ~p) : ~TT
// 
// ~TS |- ~sql1 : ~TT
// ~TS |- ~sql2 : ~TT
// ============================================ T-Union
// ~TS |- Union(~sql1, ~sql2) : ~TT
// 
// ~TS |- ~sql1 : ~TT
// ~TS |- ~sql2 : ~TT
// ============================================ T-Intersection
// ~TS |- Intersection(~sql1, ~sql2) : ~TT
// 
// ~TS |- ~sql1 : ~TT
// ~TS |- ~sql2 : ~TT
// ============================================ T-Difference
// ~TS |- Difference(~sql1, ~sql2) : ~TT



~TTC |- ~sql : ~TT
==================================================== T-inv
OR
=> exists ~al, ~rt
		~sql = TValue(table(~al, ~rt))
		typetable(table(~al, ~rt)) == ~TT
=> exists ~tn, ~rt
		~sql == SelectAll(~tn)
		clookup(~tn, ~TTC) == some(~TT)
=> exists ~tn, ~TT1, ~al, ~rt
		~sql == SelectFrom1(~al, ~tn)
		clookup(~tn, ~TTC) == some(~TT1)
		typePart(~al, ~TT1) == ~TT	
// => exists ~tn, ~p, ~rt
// 		~sql == SelectAllFromWhere1(~tn, ~p)
// 		lookup(~tn, ~TS) == some(table(~TT, ~rt))
// 		welltypedtable(table(~TT, ~rt))
// 		checkPValidity(~p, ~TT)	
// => exists ~tn, ~p, ~TT1, ~rt
// 		~sql == SelectFromWhere1(~TT, ~tn, ~p)
// 		lookup(~tn, ~TS) == some(table(~TT1, ~rt))
// 		welltypedtable(table(~TT1, ~rt))
// 		checkPValidity(~p, ~TT1)
// 		typePartOf(~TT, ~TT1)
// => exists ~sql1, ~sql2
// 		~sql == Union(~sql1, ~sql2)
// 		~TS |- ~sql1 : ~TT
// 		~TS |- ~sql2 : ~TT
// => exists ~sql1, ~sql2
// 		~sql == Intersection(~sql1, ~sql2)
// 		~TS |- ~sql1 : ~TT
// 		~TS |- ~sql2 : ~TT
// => exists ~sql1, ~sql2
// 		~sql == Difference(~sql1, ~sql2)
// 		~TS |- ~sql1 : ~TT
// 		~TS |- ~sql2 : ~TT
		
//variant of inversion lemma in several different lemmas 
//(seems to be helpful for progress proof)
axioms
~sql == TValue(table(~al, ~rt))
~TTC |- ~sql : ~TT
==================================================== T-inv-TValue
typetable(table(~al, ~rt)) == ~TT

~sql == SelectAll(~tn)		
~TTC |- ~sql : ~TT
==================================================== T-inv-SelectAll		
clookup(~tn, ~TTC) == some(~TT)

~sql == SelectFrom1(~al, ~tn)
~TTC |- ~sql : ~TT
==================================================== T-inv-SelectFrom1
exists ~TT1
	clookup(~tn, ~TTC) == some(~TT1)
	typePart(~al, ~TT1) == ~TT			
		
// ~sql == SelectAllFromWhere1(~tn, ~p)
// ~TS |- ~sql : ~TT
// ==================================================== T-inv-SelectAllFromWhere1
// exists ~rt
// 	lookup(~tn, ~TS) == some(table(~TT, ~rt))
// 	welltypedtable(table(~TT, ~rt))
// 	checkPValidity(~p, ~TT)	
// 		
// ~sql == SelectFromWhere1(~TT, ~tn, ~p)
// ~TS |- ~sql : ~TT
// ==================================================== T-inv-SelectFromWhere1
// exists ~rt, ~TT1
// 	lookup(~tn, ~TS) == some(table(~TT1, ~rt))
// 	welltypedtable(table(~TT1, ~rt))
// 	checkPValidity(~p, ~TT1)
// 	typePartOf(~TT, ~TT1)
// 		
// ~sql == Union(~sql1, ~sql2)
// ~TS |- ~sql : ~TT
// ==================================================== T-inv-Union		
// ~TS |- ~sql1 : ~TT
// ~TS |- ~sql2 : ~TT
// 
// ~sql == Intersection(~sql1, ~sql2)
// ~TS |- ~sql : ~TT
// ==================================================== T-inv-Intersection
// ~TS |- ~sql1 : ~TT
// ~TS |- ~sql2 : ~TT
// 
// ~sql == Difference(~sql1, ~sql2)
// ~TS |- ~sql : ~TT
// ==================================================== T-inv-Difference
// ~TS |- ~sql1 : ~TT
// ~TS |- ~sql2 : ~TT
