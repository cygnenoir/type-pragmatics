module sql.TypeSystem

import sql.CommonChecks
import sql.Tables
import sql.TStore
import sql.Syntax

//design decision: include welltypedtable predicate in all premises
//alternative: include this premise as a global premise later in the soundness theorem
//(but this probably does not save any work?)


axioms
//a table value with a well-typed table is typable
welltypedtable(table(~TT, ~rt))
====================================== T-TValue
~TS |- TValue(table(~TT, ~rt)) : ~TT

lookup(~tn, ~TS) == someTable(table(~TT, ~rt))
welltypedtable(table(~TT, ~rt))
=============================================== T-SelectAll
~TS |- SelectAll(~tn) : ~TT

lookup(~tn, ~TS) == someTable(table(~TT1, ~rt))
welltypedtable(table(~TT1, ~rt))
typePartOf(~TT, ~TT1)
================================================ T-SelectFrom1
~TS |- SelectFrom1(~TT, ~tn) : ~TT

lookup(~tn, ~TS) == someTable(table(~TT, ~rt))
welltypedtable(table(~TT, ~rt))
checkPValidity(~p, ~TT)
================================================ T-SelectAllFromWhere1
~TS |- SelectAllFromWhere1(~tn, ~p) : ~TT

lookup(~tn, ~TS) == someTable(table(~TT1, ~rt))
welltypedtable(table(~TT1, ~rt))
checkPValidity(~p, ~TT1)
typePartOf(~TT, ~TT1)
================================================ T-SelectFromWhere1
~TS |- SelectFromWhere1(~TT, ~tn, ~p) : ~TT

~TS |- ~sql1 : ~TT
~TS |- ~sql2 : ~TT
============================================ T-Union
~TS |- Union(~sql1, ~sql2) : ~TT

~TS |- ~sql1 : ~TT
~TS |- ~sql2 : ~TT
============================================ T-Intersection
~TS |- Intersection(~sql1, ~sql2) : ~TT

~TS |- ~sql1 : ~TT
~TS |- ~sql2 : ~TT
============================================ T-Difference
~TS |- Difference(~sql1, ~sql2) : ~TT



~TS |- ~sql : ~TT
==================================================== T-inv
OR
=> exists ~rt
		~sql = TValue(table(~TT, ~rt))
		welltypedtable(table(~TT, ~rt))
=> exists ~tn, ~rt
		~sql == SelectAll(~tn)
		lookup(~tn, ~TS) == someTable(table(~TT, ~rt))
		welltypedtable(table(~TT, ~rt))
=> exists ~tn, ~TT1, ~rt
		~sql == SelectFrom1(~TT, ~tn)
		lookup(~tn, ~TS) == someTable(table(~TT1, ~rt))
		welltypedtable(table(~TT1, ~rt))
		typePartOf(~TT, ~TT1)			
=> exists ~tn, ~p, ~rt
		~sql == SelectAllFromWhere1(~tn, ~p)
		lookup(~tn, ~TS) == someTable(table(~TT, ~rt))
		welltypedtable(table(~TT, ~rt))
		checkPValidity(~p, ~TT)	
=> exists ~tn, ~p, ~TT1, ~rt
		~sql == SelectFromWhere1(~TT, ~tn, ~p)
		lookup(~tn, ~TS) == someTable(table(~TT1, ~rt))
		welltypedtable(table(~TT1, ~rt))
		checkPValidity(~p, ~TT1)
		typePartOf(~TT, ~TT1)
=> exists ~sql1, ~sql2
		~sql == Union(~sql1, ~sql2)
		~TS |- ~sql1 : ~TT
		~TS |- ~sql2 : ~TT
=> exists ~sql1, ~sql2
		~sql == Intersection(~sql1, ~sql2)
		~TS |- ~sql1 : ~TT
		~TS |- ~sql2 : ~TT
=> exists ~sql1, ~sql2
		~sql == Difference(~sql1, ~sql2)
		~TS |- ~sql1 : ~TT
		~TS |- ~sql2 : ~TT
		
//variant of inversion lemma in several different lemmas 
//(seems to be helpful for progress proof)
axioms
~sql == TValue(table(~TT, ~rt))
~TS |- ~sql : ~TT
==================================================== T-inv-TValue
welltypedtable(table(~TT, ~rt))

~sql == SelectAll(~tn)		
~TS |- ~sql : ~TT
==================================================== T-inv-SelectAll		
exists ~rt
	lookup(~tn, ~TS) == someTable(table(~TT, ~rt))
	welltypedtable(table(~TT, ~rt))

~sql == SelectFrom1(~TT, ~tn)
~TS |- ~sql : ~TT
==================================================== T-inv-SelectFrom1
exists ~rt, ~TT1
	lookup(~tn, ~TS) == someTable(table(~TT1, ~rt))
	welltypedtable(table(~TT1, ~rt))
	typePartOf(~TT, ~TT1)		
		
~sql == SelectAllFromWhere1(~tn, ~p)
~TS |- ~sql : ~TT
==================================================== T-inv-SelectAllFromWhere1
exists ~rt
	lookup(~tn, ~TS) == someTable(table(~TT, ~rt))
	welltypedtable(table(~TT, ~rt))
	checkPValidity(~p, ~TT)	
		
~sql == SelectFromWhere1(~TT, ~tn, ~p)
~TS |- ~sql : ~TT
==================================================== T-inv-SelectFromWhere1
exists ~rt, ~TT1
	lookup(~tn, ~TS) == someTable(table(~TT1, ~rt))
	welltypedtable(table(~TT1, ~rt))
	checkPValidity(~p, ~TT1)
	typePartOf(~TT, ~TT1)
		
~sql == Union(~sql1, ~sql2)
~TS |- ~sql : ~TT
==================================================== T-inv-Union		
~TS |- ~sql1 : ~TT
~TS |- ~sql2 : ~TT

~sql == Intersection(~sql1, ~sql2)
~TS |- ~sql : ~TT
==================================================== T-inv-Intersection
~TS |- ~sql1 : ~TT
~TS |- ~sql2 : ~TT

~sql == Difference(~sql1, ~sql2)
~TS |- ~sql : ~TT
==================================================== T-inv-Difference
~TS |- ~sql1 : ~TT
~TS |- ~sql2 : ~TT
