module Subst

sorts
  Var Exp Typ Ctx OptTyp

constructors
  var : Var -> Exp
  abs : Var Typ Exp -> Exp
  app : Exp Exp -> Exp

  empty : Ctx
  bind : Var Typ Ctx -> Ctx

  arrow : Typ Typ -> Typ
  
  nothing : OptTyp
  some : Typ -> OptTyp

function
lookup : Var Ctx -> OptTyp
lookup(x, empty) = nothing
lookup(x, bind(y, Ty, C)) = 
  if (x == y)
  then some(Ty)
  else lookup(x, C)

// **********
// type rules
// **********

axioms

lookup(~x, ~C) == some(~T)
========================== T-var
~C |- var(~x) : ~T

bind(~x, ~S, ~C) |- ~e : ~T
===================================== T-abs
~C |- abs(~x, ~S, ~e) : arrow(~S, ~T)

~C |- ~e1 : arrow(~S, ~T)
~C |- ~e2 : ~S
========================= T-app
~C |- app(~e1, ~e2) : ~T



~C |- ~e : ~T
=============================== T-inv
OR
=> exists ~x
     ~e == var(~x)
     lookup(~x, ~C) == some(~T)
=> exists ~x, ~e2, ~T1, ~T2
     ~e == abs(~x, ~T1, ~e2)
     ~T == arrow(~T1, ~T2)
     bind(~x, ~T1, ~C) |- ~e2 : ~T2
=> exists ~e1, ~e2, ~S
     ~e == app(~e1, ~e2)
     ~C |- ~e1 : arrow(~S, ~T)
     ~C |- ~e2 : ~S


// *************************
// Context rules
// *************************

function
isFreeVar : Var Exp -> Bool
isFreeVar(v, var(x)) = x == v
isFreeVar(v, abs(x, T, e)) = x != v && isFreeVar(v, e) 
isFreeVar(v, app(e1, e2))= isFreeVar(v, e1) || isFreeVar(v, e2)

axioms
~x == ~y
bind(~x, ~Tx, bind(~y, ~Ty, ~C)) |- ~e : ~T
=========================================== T-Context-Duplicate
bind(~x, ~Tx, ~C) |- ~e : ~T

~x != ~y
bind(~x, ~Tx, bind(~y, ~Ty, ~C)) |- ~e : ~T
=========================================== T-Context-Swap
bind(~y, ~Ty, bind(~x, ~Tx, ~C)) |- ~e : ~T

!isFreeVar(~x, ~e)
~C |- ~e : ~T
=========================== T-Weak
bind(~x, ~S, ~C) |- ~e : ~T




// ******************
// Substitution lemma
// ******************

function
subst : Var Exp Exp -> Exp
subst(x, e, var(y)) =
	if x == y
	then e
	else var(y)
subst(x, e, app(e1, e2)) = app(subst(x, e, e1), subst(x, e, e2))
subst(x, e, abs(y, T, e1)) =
	if x == y
	then abs(y, T, e1)
	else abs(y, T, subst(x, e, e1))

// This is what we want prove by induction
//
// ~C |- ~e : ~T
// bind(~x, ~T, ~C) |- ~e2 : ~T2
// ============================== T-subst
// ~C |- subst(~x, ~e, ~e2) : ~T2

// Prove substitution lemma by induction on recursive structure of `subst`
// Each derived rule represents one induction case.

goal
~e2 == var(~y)
~x == ~y
~C |- ~e : ~T
bind(~x, ~T, ~C) |- ~e2 : ~T2
============================== T-subst-var-1
~C |- subst(~x, ~e, ~e2) : ~T2

goal
~e2 == var(~y)
~x != ~y
~C |- ~e : ~T
bind(~x, ~T, ~C) |- ~e2 : ~T2
============================== T-subst-var-2
~C |- subst(~x, ~e, ~e2) : ~T2

local {
	// consts
	// 	e1app : Exp
	// 	e2app : Exp
	// 
	axioms
	~C |- ~e : ~T
	bind(~x, ~T, ~C) |- e1app : ~T2
	============================== T-subst-IH-app1
	~C |- subst(~x, ~e, e1app) : ~T2
	
	~C |- ~e : ~T
	bind(~x, ~T, ~C) |- e2app : ~T2
	============================== T-subst-IH-app2
	~C |- subst(~x, ~e, e2app) : ~T2
	
	goal
	~e2 == app(e1app, e2app)
	~C |- ~e : ~T
	bind(~x, ~T, ~C) |- ~e2 : ~T2
	============================== T-subst-app
	~C |- subst(~x, ~e, ~e2) : ~T2
}

goal
~e2 == abs(~y, ~S, ~e3)
~x == ~y
~C |- ~e : ~T
bind(~x, ~T, ~C) |- ~e2 : ~T2
================================ T-subst-abs-1
~C |- subst(~x, ~e, ~e2) : ~T2

local {
	const eabs : Exp
	
	axiom
	~C |- ~e : ~T
	bind(~x, ~T, ~C) |- eabs : ~T2
	============================== T-subst-IH-abs
	~C |- subst(~x, ~e, eabs) : ~T2

	goal
	~e2 == abs(~y, ~S, eabs)
	~x != ~y
	~C |- ~e : ~T
	bind(~x, ~T, ~C) |- ~e2 : ~T2
	================================================= T-subst-abs-2
	bind(~x, ~T, ~C) |- abs(~y, ~S, eabs) : ~T2
	exists ~S2
		~T2 == arrow(~S, ~S2)
		bind(~y, ~S, bind(~x, ~T, ~C)) |- eabs : ~S2
		bind(~x, ~T, bind(~y, ~S, ~C)) |- eabs : ~S2
		// bind(~y, ~S, ~C) |- subst(~x, ~e, eabs) : ~S2
	// ~C |- subst(~x, ~e, ~e2) : ~T2
}

// substitution lemma becomes an axiom after the proof
axiom
~C |- ~e : ~T
bind(~x, ~T, ~C) |- ~e2 : ~T2
============================== T-subst
~C |- subst(~x, ~e, ~e2) : ~T2
