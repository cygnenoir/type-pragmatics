module Subst

axioms

// ***************************
// Equational theory for terms
// ***************************


var(~x) = var(~y)
================= Cong-var-true
~x = ~y

var(~x) != var(~y)
================== Cong-var-false
~x != ~y

~e1 ~f1 = ~e2 ~f2
====================== Cong-app-true
~e1 = ~e2
~f1 = ~f2

~e1 ~f1 != ~e2 ~f2
======================= Cong-app-false
OR
=> ~e1 != ~e2
=> ~f1 != ~f2

\~x1:~T1. ~e1 = \~x2:~T2. ~e2
============================= Cong-abs-true
~x1 = ~x2
~T1 = ~T2
~e1 = ~e2

\~x1:~T1. ~e1 != \~x2:~T2. ~e2
============================= Cong-abs-false
OR
=> ~x1 != ~x2
=> ~T1 != ~T2
=> ~e1 != ~e2

~T1 -> ~T2 = ~U1 -> ~U2
======================= Cong-arrow-true
~T1 = ~U1
~T2 = ~U2

~T1 -> ~T2 != ~U1 -> ~U2
======================== Cong-arrow-false
OR
=> ~T1 != ~U1
=> ~T2 != ~U2


================== Cong-var-app
var(~x) != ~e1 ~e2

===================== Cong-var-abs
var(~x) != \~y:~T. ~e

===================== Cong-abs-app
\~x:~T. ~e != ~e1 ~e2 


// *************************
// Context rules
// *************************

~x:~T in (~x:~T2; ~C)
====================== Lookup-Base
~T = ~T2

~x != ~y
~x:~T in ~C
====================== Lookup-Step
~x:~T2 in (~y:~Ty; ~C)
~T = ~T2

~x1 != ~x2
~C1 = ~C2
================================================= Context-Swap
(~x1:~T1; ~x2:~T2; ~C1) = (~x2:~T2; ~x1:~T1; ~C2)

~C1 = ~C2
===================================== Context-Duplicate
(~x:~T1; ~x:~T2; ~C1) = (~x:~T1; ~C2)

~C |- ~e : ~T
====================== T-Weak
(~x:~S; ~C) |- ~e : ~T



// **********
// type rules
// **********


~x:~T in ~C
================== T-var
~C |- var(~x) : ~T

(~X:~S; ~C) |- ~E : ~T
===================================== T-abs
~C |- (\~X:~S. ~E) : ~S -> ~T

~C |- ~e1 : ~S -> ~T
~C |- ~e2 : ~S
==================== T-app
~C |- ~e1 ~e2 : ~T



~C |- ~e : ~T
=============================== T-inv
OR
=> exists ~x
     ~e = var(~x)
     ~x:~T in ~C
=> exists ~x, ~e2, ~T1, ~T2
     ~e = \~x:~T1. ~e2
     ~T = ~T1 -> ~T2
     (~x:~T1; ~C) |- ~e2 : ~T2
=> exists ~e1, ~e2, ~S
     ~e = ~e1 ~e2
     ~C |- ~e1 : ~S -> ~T
     ~C |- ~e2 : ~S


// ******************
// Substitution lemma
// ******************

// This is what we want prove by induction
//
// ~C |- ~e : ~T
// (~x:~T; ~C) |- ~e2 : ~T2
// ============================== T-subst
// ~C |- subst(~x, ~e, ~e2) : ~T2

// Prove substitution lemma by induction on recursive structure of `subst`
// Each derived rule represents one induction case.

goal
~e2 = var(~x)
subst(~x, ~e, ~e2) = ~e
~C |- ~e : ~T
(~x:~T; ~C) |- ~e2 : ~T2
============================== T-subst-var-1
~C |- subst(~x, ~e, ~e2) : ~T2

goal
~e2 = var(~x)
~x != ~y
subst(~y, ~e, ~e2) = ~e2
~C |- ~e : ~T
(~x:~T; ~C) |- ~e2 : ~T2
============================== T-subst-var-2
~C |- subst(~x, ~e, ~e2) : ~T2

local {
	axioms
	~C |- ~e : ~T
	(~x:~T; ~C) |- e1app : ~T2
	============================== T-subst-IH-app1
	~C |- subst(~x, ~e, e1app) : ~T2
	
	~C |- ~e : ~T
	(~x:~T; ~C) |- e2app : ~T2
	============================== T-subst-IH-app2
	~C |- subst(~x, ~e, e2app) : ~T2
	
	goal
	~e2 = e1app e2app
	subst(~x, ~e, ~e2) = subst(~x, ~e, e1app) subst(~x, ~e, e2app)
	~C |- ~e : ~T
	(~x:~T; ~C) |- ~e2 : ~T2
	============================================================== T-subst-app
	~C |- subst(~x, ~e, ~e2) : ~T2
}

goal
~e2 = \~y:~S. ~e3
~x = ~y
subst(~x, ~e, ~e2) = \~y:~s. ~e3
~C |- ~e : ~T
(~x:~T; ~C) |- ~e2 : ~T2
================================ T-subst-abs-1
~C |- subst(~x, ~e, ~e2) : ~T2

local {
	axiom
	~C |- ~e : ~T
	(~x:~T; ~C) |- eabs : ~T2
	============================== T-subst-IH-abs
	~C |- subst(~x, ~e, eabs) : ~T2

	goal
	~e2 = \~y:~S. eabs
	~x != ~y
	subst(~x, ~e, ~e2) = \~y:~S. subst(~x, ~e, eabs)
	~C |- ~e : ~T
	(~x:~T; ~C) |- ~e2 : ~T2
	================================================= T-subst-abs-2
	~C |- subst(~x, ~e, ~e2) : ~T2
}

// substitution lemma becomes an axiom after the proof
axiom
~C |- ~e : ~T
(~x:~T; ~C) |- ~e2 : ~T2
============================== T-subst
~C |- subst(~x, ~e, ~e2) : ~T2
