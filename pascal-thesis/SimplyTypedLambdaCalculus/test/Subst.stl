module Subst

sorts
  Var Exp Typ Ctx

constructors
  var : Var -> Exp
  abs : Var Typ Exp -> Exp
  app : Exp Exp -> Exp

  empty : Ctx
  bind : Var Typ Ctx -> Ctx

  arrow : Typ Typ -> Typ  

axioms

// *************************
// Context rules
// *************************

~x:~T in (~x:~T2; ~C)
====================== Lookup-Base
~T = ~T2

~x != ~y
~x:~T in ~C
====================== Lookup-Step
~x:~T2 in (~y:~Ty; ~C)
~T = ~T2

~x1 != ~x2
~C1 = ~C2
================================================= Context-Swap
(~x1:~T1; ~x2:~T2; ~C1) = (~x2:~T2; ~x1:~T1; ~C2)

~C1 = ~C2
===================================== Context-Duplicate
(~x:~T1; ~x:~T2; ~C1) = (~x:~T1; ~C2)

~C |- ~e : ~T
====================== T-Weak
(~x:~S; ~C) |- ~e : ~T



// **********
// type rules
// **********


~x:~T in ~C
================== T-var
~C |- var(~x) : ~T

(~X:~S; ~C) |- ~E : ~T
===================================== T-abs
~C |- (\~X:~S. ~E) : ~S -> ~T

~C |- ~e1 : ~S -> ~T
~C |- ~e2 : ~S
==================== T-app
~C |- ~e1 ~e2 : ~T



~C |- ~e : ~T
=============================== T-inv
OR
=> exists ~x
     ~e = var(~x)
     ~x:~T in ~C
=> exists ~x, ~e2, ~T1, ~T2
     ~e = \~x:~T1. ~e2
     ~T = ~T1 -> ~T2
     (~x:~T1; ~C) |- ~e2 : ~T2
=> exists ~e1, ~e2, ~S
     ~e = ~e1 ~e2
     ~C |- ~e1 : ~S -> ~T
     ~C |- ~e2 : ~S


// ******************
// Substitution lemma
// ******************

// This is what we want prove by induction
//
// ~C |- ~e : ~T
// (~x:~T; ~C) |- ~e2 : ~T2
// ============================== T-subst
// ~C |- subst(~x, ~e, ~e2) : ~T2

// Prove substitution lemma by induction on recursive structure of `subst`
// Each derived rule represents one induction case.

goal
~e2 = var(~x)
subst(~x, ~e, ~e2) = ~e
~C |- ~e : ~T
(~x:~T; ~C) |- ~e2 : ~T2
============================== T-subst-var-1
~C |- subst(~x, ~e, ~e2) : ~T2

goal
~e2 = var(~x)
~x != ~y
subst(~y, ~e, ~e2) = ~e2
~C |- ~e : ~T
(~x:~T; ~C) |- ~e2 : ~T2
============================== T-subst-var-2
~C |- subst(~x, ~e, ~e2) : ~T2

local {
	axioms
	~C |- ~e : ~T
	(~x:~T; ~C) |- e1app : ~T2
	============================== T-subst-IH-app1
	~C |- subst(~x, ~e, e1app) : ~T2
	
	~C |- ~e : ~T
	(~x:~T; ~C) |- e2app : ~T2
	============================== T-subst-IH-app2
	~C |- subst(~x, ~e, e2app) : ~T2
	
	goal
	~e2 = e1app e2app
	subst(~x, ~e, ~e2) = subst(~x, ~e, e1app) subst(~x, ~e, e2app)
	~C |- ~e : ~T
	(~x:~T; ~C) |- ~e2 : ~T2
	============================================================== T-subst-app
	~C |- subst(~x, ~e, ~e2) : ~T2
}

goal
~e2 = \~y:~S. ~e3
~x = ~y
subst(~x, ~e, ~e2) = \~y:~s. ~e3
~C |- ~e : ~T
(~x:~T; ~C) |- ~e2 : ~T2
================================ T-subst-abs-1
~C |- subst(~x, ~e, ~e2) : ~T2

local {
	axiom
	~C |- ~e : ~T
	(~x:~T; ~C) |- eabs : ~T2
	============================== T-subst-IH-abs
	~C |- subst(~x, ~e, eabs) : ~T2

	goal
	~e2 = \~y:~S. eabs
	~x != ~y
	subst(~x, ~e, ~e2) = \~y:~S. subst(~x, ~e, eabs)
	~C |- ~e : ~T
	(~x:~T; ~C) |- ~e2 : ~T2
	================================================= T-subst-abs-2
	~C |- subst(~x, ~e, ~e2) : ~T2
}

// substitution lemma becomes an axiom after the proof
axiom
~C |- ~e : ~T
(~x:~T; ~C) |- ~e2 : ~T2
============================== T-subst
~C |- subst(~x, ~e, ~e2) : ~T2
