module stlc.Preservation

import stlc.Syntax
import stlc.Subst
import stlc.Reduction
import stlc.Types

// 1. Substitution lemma
// 2. Type preservation of reduction

goal
~e2 == var(~y)
~x == ~y
~C |- ~e : ~T
bind(~x, ~T, ~C) |- ~e2 : ~T2
============================== T-subst-var-1
~C |- subst(~x, ~e, ~e2) : ~T2

goal
~e2 == var(~y)
~x != ~y
~C |- ~e : ~T
bind(~x, ~T, ~C) |- ~e2 : ~T2
============================== T-subst-var-2
~C |- subst(~x, ~e, ~e2) : ~T2

local {
	consts
		e1app : Exp
		e2app : Exp
	
	axioms
	~C |- ~e : ~T
	bind(~x, ~T, ~C) |- e1app : ~T2
	============================== T-subst-IH-app1
	~C |- subst(~x, ~e, e1app) : ~T2
	
	~C |- ~e : ~T
	bind(~x, ~T, ~C) |- e2app : ~T2
	============================== T-subst-IH-app2
	~C |- subst(~x, ~e, e2app) : ~T2
	
	goal
	~e2 == app(e1app, e2app)
	~C |- ~e : ~T
	bind(~x, ~T, ~C) |- ~e2 : ~T2
	============================== T-subst-app
	~C |- subst(~x, ~e, ~e2) : ~T2
}

goal
~e2 == abs(~y, ~S, ~e1)
~x == ~y
~C |- ~e : ~T
bind(~x, ~T, ~C) |- ~e2 : ~T2
============================== T-subst-abs-1
~C |- subst(~x, ~e, ~e2) : ~T2


local {
	const eabs : Exp
	
	axiom
	~C |- ~e : ~T
	bind(~x, ~T, ~C) |- eabs : ~T2
	============================== T-subst-IH-abs
	~C |- subst(~x, ~e, eabs) : ~T2

	goal
	~e2 == abs(~y, ~S, eabs)
	~x != ~y
	isFreeVar(~y, ~e)
	~C |- ~e : ~T
	bind(~x, ~T, ~C) |- ~e2 : ~T2
	~fresh == gensym(app(app(~e, eabs), var(~x)))
	~C2 == bind(~x, ~T, ~C)
	~C3 == bind(~fresh, ~S, ~C2)
	================================================= T-subst-abs-2
	bind(~x, ~T, ~C) |- abs(~y, ~S, eabs) : ~T2
	exists ~S2
		~T2 == arrow(~S,~S2)
		bind(~y, ~S, ~C2) |- eabs : ~S2
		bind(~fresh, ~S, bind(~y, ~S, ~C2)) |- eabs : ~S2
		~fresh != ~y
		~C3 |- var(~fresh) : ~S
		bind(~y, ~S, ~C3) |- eabs : ~S2
		bind(~fresh, ~S, bind(~x, ~T, ~C)) |- subst(~y, var(~fresh), eabs) : ~S2
		~fresh != ~x
		bind(~x, ~T, bind(~fresh, ~S, ~C)) |- subst(~y, var(~fresh), eabs) : ~S2
		bind(~fresh, ~S, ~C) |- subst(~x, ~e, subst(~y, var(~fresh), eabs)) : ~S2
		// subst(~y, var(gensym2(~e, eabs)), eabs)
	// ~C |- abs(~fresh, ~S, subst(~x, ~e, subst(~y, var(~fresh), eabs))) : ~T2
}

local {
	const eabs : Exp
	
	axiom
	~C |- ~e : ~T
	bind(~x, ~T, ~C) |- eabs : ~T2
	============================== T-subst-IH-abs
	~C |- subst(~x, ~e, eabs) : ~T2

	goal
	~e2 == abs(~y, ~S, eabs)
	~x != ~y
	!isFreeVar(~y, ~e)
	~C |- ~e : ~T
	bind(~x, ~T, ~C) |- ~e2 : ~T2
	================================================= T-subst-abs-3
	~C |- subst(~x, ~e, ~e2) : ~T2
}

// substitution lemma becomes an axiom after the proof
axiom
~C |- ~e : ~T
bind(~x, ~T, ~C) |- ~e2 : ~T2
============================== T-subst
~C |- subst(~x, ~e, ~e2) : ~T2




// Prove type preservation by induction on recursive structure of reduction relation
// Each derived rule represents one induction case.

goal
~ein == app(abs(~x, ~S, ~e1), ~e2)
~eout == subst(~x, ~e2, ~e1)
~C |- ~ein : ~T
======================================== T-Preservation-beta
~C |- subst(~x, ~e2, ~e1) : ~T 

local {
	consts
		e1 : Exp
		e1red : Exp
	
	axiom	 
	~C |- e1 : ~T
	reduce(e1, e1red)
	======================= T-Preservation-IH-app1
	~C |- e1red : ~T

	goal
	~ein == app(e1, ~e2)
	~eout == app(e1red, ~e2)
	reduce(e1, e1red)
	~C |- ~ein : ~T
	================================ T-Preservation-App1
	~C |- ~eout : ~T
}

local {
	consts
		e2 : Exp
		e2red : Exp
	
	axiom
	~C |- e2 : ~T
	reduce(e2, e2red)
	================= T-Preservation-IH-app2
	~C |- e2red : ~T

	goal	
	~ein == app(~e1, e2)
	~eout == app(~e1, e2red)
	reduce(e2, e2red)
	~C |- ~ein : ~T
	================================ T-Preservation-App2
	~C |- ~eout : ~T
}
