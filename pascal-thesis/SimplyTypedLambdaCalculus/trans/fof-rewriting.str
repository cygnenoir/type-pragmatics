module fof-rewriting

imports include/STLC
imports libstratego-lib
imports names

signature
	sorts Prop FOF File
	constructors
		// Constructors that are commented are currently not used.
		False : Prop
    	True  : Prop
    	// Atom  : String -> Prop
    	Not   : Prop -> Prop
    	And   : Prop * Prop -> Prop
    	Or    : Prop * Prop -> Prop
    	Impl  : List(Prop) * Prop -> Prop
    	BiImpl  : Prop * Prop -> Prop
    	Eq    : Prop * Prop -> Prop
    	Neq : Prop * Prop -> Prop
    	Var   : String -> Prop
    	Pred  : String * List(Prop) -> Prop //TODO: Make this more typesafe
    	TermApp  : String * List(Prop) -> Prop //TODO: Make this more typesafe 
    	All   : List(Var) * Prop -> Prop
    	Exists : List(Var) * Prop -> Prop
    	
    	Axiom : Type
    	Conjecture : Type
    	Formula : String * Type * Prop -> FOF
    	Formula : String * Prop -> FOF
    	
    	FOFGoal : List(Formula) * Formula -> File
    	RelBool : Sort

rules
	R : FunctionExpVar(v) -> Var(v)
	R : FunctionExpMeta(Meta(v)) -> Meta(v)
	R : FunctionExpNeq(t1, t2) -> Neq(t1, t2)
	R : FunctionExpEq(t1, t2) -> Eq(t1, t2)
	R : FunctionExpNot(t) -> Not(t)
	R : FunctionExpApp(f, args) -> <make-termapp> (f, args)
	
	R : PremiseList(p) -> p
	R : ConsequenceList(p) -> p
	R : JudgementCons(j1, j2) -> And(j1, j2)
	R : TypingJudgment(CTX, E, T) -> Pred("tcheck", [CTX, E, T])
	R : ReduceJudgment(e1, e2) -> Pred("reduce", [e1, e2])
	R : FunctionExpJudgment(e) -> e
	R : ExistsJudgment(vars, prop) -> Exists(vars, prop)
	R : NotJudgment(j) -> Not(j)
	R : OrJudgement(p) -> p
	R : OrEnd(p) -> p
	R : OrCons(p1, p2) -> Or(p1, p2)
	
	// R : Plus(e1, e2) -> TermApp("plus", [e1, e2])
	// R : Rational(e1, e2) -> TermApp("rat", [e1, e2])
	// R : App(e1, e2) -> TermApp("app", [e1, e2])
	// R : FApp(name, es) -> TermApp(name, es)
	// R : Abs(Meta(v), e2, e3) -> TermApp("abs", [Meta(v), e2, e3])
	// R : Abs(e1, e2, e3) -> TermApp("abs", [Var(e1), e2, e3])
	// R : TyFunction(e1, e2) -> TermApp("arrow", [e1, e2])
	// R : TyFuture(e1) -> TermApp("future", [e1])
	// R : TyNat() -> Var("nat")
	// R : TyVar(v) -> Var(v)
	// R : Meta(v) -> Var(v)
	// R : MetaVariable(v) -> v
	R : Var(v) -> Var(v2)
		where v2 := <string-as-chars([to-lower|id])> v
		    ; <not(equal)> (v, v2)
	R : Meta(v) -> Meta(v2)
		where v2 := <string-as-chars([to-upper|id])> v
		    ; <not(equal)> (v, v2)
	
	// R : Fork(x) -> TermApp("fork", [x])
	// R : Join(x) -> TermApp("join", [x])
	// R : Par(x) -> TermApp("par", [x])
	

	
	R : TypingRule(name, CONSEQUENCE) -> TypingRule(True(), name, CONSEQUENCE)
	R : TypingRule(PREMISES, RuleName(_, NAME), CONSEQUENCE) ->
		Formula(NAME, all-term)
		with
			//TODO: In which cases can meta-variables be bound?
			body := <try(\ Impl(True(), p) -> p \)> Impl(PREMISES, CONSEQUENCE);
			metaVars := <collect-all(?Meta(_))> (PREMISES, CONSEQUENCE);
			existsVars := <collect-all(?ExistsJudgment(<id>,_) + ?Exists(<id>,_)); concat> (PREMISES, CONSEQUENCE);
			universalVars := <diff> (metaVars, existsVars);
			all-term := <make-all> (universalVars, body)

	make-exists : ([], body) -> body
	make-exists : (vars, body) -> Exists(vars, body)
	make-all : ([], body) -> body
	make-all : (vars, body) -> All(vars, body)
	make-termapp : (v, []) -> <make-var> v
	make-termapp : (v, args) -> TermApp(<make-var;?Var(<id>)> v, args)
	make-var = string-as-chars([to-lower|id]); !Var(<id>)
	make-meta = string-as-chars([to-upper|id]); !Meta(<id>)
	make-eq : (t1{RelBool()}, t2) -> Impl(t2,t1{RelBool()})
	make-eq : (t1, t2) -> Eq(t1, t2)
			
	compose-formula-p :
		(Formula(N1, P1), Formula(N2, P2)) -> Formula(N, P)
	where
		N := <conc-strings> (N1, " AND ", N2);
		P := And(P1, P2)
	compose-formula-p = debug(!"compose-formula-p failed: "); fail

	compose-formulas = reduce-list(compose-formula-p)
	
	reduce-list(s) = ?[] <+ ?[<id>] <+ foldr1(s)
	reduce-list(s|init) = (?[];!init) <+ ?[<id>] <+ foldr1(s)

rules
	// lookup-ctx-base = !Formula("lookup ctx base", Axiom(), All([Meta("X"), Meta("T"), Meta("T2"), Meta("CTX")],
	//                      Impl(Pred("lookup", [Meta("X"), TermApp("bind", [Meta("X"), Meta("T2"), Meta("CTX")]), Meta("T")]),
	//                           Eq(Meta("T"), Meta("T2")))))
	// lookup-ctx-step = !Formula("lookup ctx step", Axiom(), All([Meta("X"), Meta("Y"), Meta("T"), Meta("T2"), Meta("CTX")],
	//                      Impl(And(Neq(Meta("X"), Meta("Y")), Pred("lookup", [Meta("X"), Meta("CTX"), Meta("T")])),
	//                           Pred("lookup", [Meta("X"), TermApp("bind", [Meta("Y"), Meta("T2"), Meta("CTX")]), Meta("T")]))))
	// base-rules = ![<lookup-ctx-base>, <lookup-ctx-step>]

	constructor-axiom : ConstructorDecl(name, args, res) -> Formula(ax-name, Axiom(), <make-all> (vars, BiImpl(Eq(t1, t2), arg-eqs-and)))
	where
		ax-name := <conc-strings> ("EQ-", name);
		args1 := <map(?SortRef(<id>); newname; make-meta)> args;
		args2 := <map(?SortRef(<id>); newname; make-meta)> args;
		vars := <conc> (args1, args2);
		t1 := <make-termapp> (name, args1);
		t2 := <make-termapp> (name, args2);
		arg-eqs := <zip; map(\(a1, a2) -> Eq(a1, a2)\)> (args1, args2);
		arg-eqs-and := <reduce-list(\(p1, p2) -> And(p1, p2)\|True())> arg-eqs
	constructor-axiom = debug(!"constructor-axioms failed: "); fail

	constructor-diff-axioms(|cons) : [] -> []
	constructor-diff-axioms(|cons) : [c|cs] -> <conc> (c-axioms, others)
	where
		c-axioms := <map(\cons-c -> <constructor-diff-axiom> (cons-c, c)\); filter(not(?None()))> cons;
		new-cons := <conc> (cons, [c]);
		others := <constructor-diff-axioms(|new-cons)> cs
	
	constructor-diff-axiom :
		(ConstructorDecl(old-name, old-args, old-res), ConstructorDecl(new-name, new-args, new-res)) ->
		Formula(ax-name, Axiom(), <make-all> (vars, Neq(old-t, new-t)))
	where
		<equal> (old-res, new-res);
		ax-name := <conc-strings> ("DIFF-",old-name,"-",new-name);
		old-vars := <map(?SortRef(<id>); newname; make-meta)> old-args;
		new-vars := <map(?SortRef(<id>); newname; make-meta)> new-args;
		vars := <conc> (old-vars, new-vars);
		old-t := <make-termapp> (old-name, old-vars);
		new-t := <make-termapp> (new-name, new-vars)
	constructor-diff-axiom :
		(ConstructorDecl(old-name, old-args, old-res), ConstructorDecl(new-name, new-args, new-res)) ->
		None()
	where
		<not(equal)> (old-res, new-res)
	constructor-diff-axiom = debug(!"constructor-diff-axiom failed: "); fail
		
		
	function-axioms(|cons) : FunctionDef(FunctionSig(_,arg-types,res-type), eqs) -> <mapconcat(function-eq-axioms(|arg-types, res-type, cons))> eqs
	
	function-eq-axioms(|arg-types, res-type, cons) : FunctionEq(name, pats, exp) -> result
	where
		<not(?RelBool())> res-type;
		arg-vars := <map(?SortRef(<id>); newname; make-meta)> arg-types;
		result-term := <make-termapp> (name, arg-vars);
		result-var := Meta(<newname> "RESULT");
		result-bind := Eq(result-var, result-term);
		pat-binds :=  <map(function-pat-prop(|cons))> pats;
		pat-props := <zip; map(\(a,b) -> Eq(a,b)\)> (arg-vars, pat-binds);
		pat-prop := <reduce-list(\(p1, p2) -> And(p1, p2)\|True())> pat-props;
		exp-props := <function-exp-props(|cons)> exp;
		result := <map(make-function-formula(|name, And(pat-prop, result-bind), result-var))> exp-props 
	function-eq-axioms(|arg-types, res-type, cons) : FunctionEq(name, pats, exp) -> result
	where
		<?RelBool()> res-type;
		arg-vars := <map(?SortRef(<id>); newname; make-meta)> arg-types;
		result-term := <make-termapp> (name, arg-vars);
		pat-binds :=  <map(function-pat-prop(|cons))> pats;
		pat-props := <zip; map(\(a,b) -> Eq(a,b)\)> (arg-vars, pat-binds);
		pat-prop := <reduce-list(\(p1, p2) -> And(p1, p2)\|True())> pat-props;
		exp-props := <function-exp-props(|cons)> exp;
		result := <map(make-function-formula(|name, pat-prop, result-term{RelBool()}))> exp-props 
	function-eq-axioms(|arg-sorts) = debug(!"function-eq-axioms failed: "); fail
	
	function-pat-prop(|cons) : FunctionPatVar(v) -> <make-var> v
	where <elem(|v)> cons
	function-pat-prop(|cons) : FunctionPatVar(v) -> <make-meta> v
	where <not(elem(|v))> cons
	
	function-pat-prop(|cons) : FunctionPatApp(f, ts) -> <make-termapp> (f, args)
	where
		args := <map(function-pat-prop(|cons))> ts
	function-pat-prop(|cons) = debug(!"function-pat-prop failed: "); fail
	
	function-exp-props(|cons) : FunctionExpUndefined() -> []
	function-exp-props(|cons) : FunctionExpVar(v) -> [(True(),<make-var> v)]
	where <elem(|v)> cons
	function-exp-props(|cons) : FunctionExpVar(v) -> [(True(),<make-meta> v)]
	where <not(elem(|v))> cons
	function-exp-props(|cons) : FunctionExpIf(c, t, e) -> <conc> (result1, result2)
	where
		[(True(), c-prop)] := <function-exp-props(|cons)> c; // TODO support conditionals in condition
		t-props := <function-exp-props(|cons)> t;
		e-props := <function-exp-props(|cons)> e;
		result1 := <map(\(a,b) -> (And(c-prop,a), b)\)> t-props;
		result2 := <map(\(a,b) -> (And(Not(c-prop),a), b)\)> e-props
	function-exp-props(|cons) : FunctionExpEq(e1, e2) -> [(True(), Eq(e1-prop, e2-prop))]
	where
		[(True(), e1-prop)] := <function-exp-props(|cons)> e1; // TODO support conditionals in operands
		[(True(), e2-prop)] := <function-exp-props(|cons)> e2; // TODO support conditionals in operands
		id
	function-exp-props(|cons) : FunctionExpNeq(e1, e2) -> [(True(), Neq(e1-prop, e2-prop))]
	where
		[(True(), e1-prop)] := <function-exp-props(|cons)> e1; // TODO support conditionals in operands
		[(True(), e2-prop)] := <function-exp-props(|cons)> e2; // TODO support conditionals in operands
		id
	function-exp-props(|cons) : FunctionExpAnd(e1, e2) -> [(True(), And(e1-prop, e2-prop))]
	where
		[(True(), e1-prop)] := <function-exp-props(|cons)> e1; // TODO support conditionals in operands
		[(True(), e2-prop)] := <function-exp-props(|cons)> e2; // TODO support conditionals in operands
		id
	function-exp-props(|cons) : FunctionExpOr(e1, e2) -> [(True(), Or(e1-prop, e2-prop))]
	where
		[(True(), e1-prop)] := <function-exp-props(|cons)> e1; // TODO support conditionals in operands
		[(True(), e2-prop)] := <function-exp-props(|cons)> e2; // TODO support conditionals in operands
		id
	function-exp-props(|cons) : FunctionExpNot(e) -> [(True(), Not(e-prop))]
	where
		[(True(), e-prop)] := <function-exp-props(|cons)> e; // TODO support conditionals in operands
		id
	function-exp-props(|cons) : FunctionExpApp(f, es) -> [(True(), <make-termapp> (f, es-props))]
	where
		es-props := <map(function-exp-props(|cons); ?[(True(), <id>)])> es // TODO support conditionals as function arguments
	function-exp-props(|cons) = debug(!"function-exp-props(|name, pat-props) failed: "); fail

	make-function-formula(|name, pat-prop, result-var) : 
		(cond, p) -> 
		Formula(fname, Axiom(), <make-all>(vars, body))
	where
		fname := <newname> name;
		body := Impl(pat-prop, Impl(cond, <make-eq> (result-var, p)));
		vars := <collect-all(?Meta(_))> body
	
	crossproduct : ([], ys) -> []
	crossproduct : (xs, []) -> []
	crossproduct : ([x|xs], ys) -> <conc> (<map(\ y -> (x,y)\)> ys, <crossproduct> (xs, ys))
	
	elem(|t) = where(!(<strip-annos> t, <id>); elem)
	
	put-type(|t) = ?term; !term{t}

strategies
	to-prop = innermost(R)
	fof-trans = generate-fof-goals
	
	generate-fof-goals : Module(_, imps, body) -> <conc; generate-fof-goals(|[], [])> (imps, body) 
	
	generate-fof-goals(|axioms, cons) : [] -> []
	generate-fof-goals(|axioms, cons) : [Axioms(fs) | rest] -> others
		where
			newAxioms := <to-prop; map(\Formula(name,body) -> Formula(name, Axiom(), body)\)> fs;
			axioms2 := <conc> (axioms, newAxioms); 
			others := <generate-fof-goals(|axioms2, cons)> rest
	generate-fof-goals(|axioms, cons) : [Goals(fs) | rest] -> [goal | others]
		where
			formula := <to-prop; compose-formulas> fs;
			conjecture := <\Formula(name,body) -> Formula(name, Conjecture(), body)\> formula;
			goal := FOFGoal(axioms, conjecture);
			others := <generate-fof-goals(|axioms, cons)> rest
	generate-fof-goals(|axioms, cons) : [Local(xs) | rest] -> <conc> (goals,  others)
		where
			goals := <generate-fof-goals(|axioms, cons)> xs;
			others := <generate-fof-goals(|axioms, cons)> rest
	generate-fof-goals(|axioms, cons) : [Sorts(xs) | rest] -> others
		where
			others := <generate-fof-goals(|axioms, cons)> rest
	generate-fof-goals(|axioms, cons) : [Constructors(cs) | rest] -> others
		where
			cs-axioms := <map(constructor-axiom)> cs;
			cs-diff-axioms := <constructor-diff-axioms(|cons)> cs;
			axioms2 := <conc> (axioms, cs-axioms, cs-diff-axioms); 
			cons2 := <conc> (cons, cs);
			others := <generate-fof-goals(|axioms2, cons2)> rest
	generate-fof-goals(|axioms, cons) : [Consts(cs) | rest] -> others
		where
			cs-axioms := <map(constructor-axiom)> cs;
			axioms2 := <conc> (axioms, cs-axioms); 
			cons2 := <conc> (cons, cs);
			others := <generate-fof-goals(|axioms2, cons2)> rest
	generate-fof-goals(|axioms, cons) : [Functions(fs) | rest] -> others
		where
			cons-names := <map(?ConstructorDecl(<id>, _, _); strip-annos)> cons;
			fs-axioms := <mapconcat(function-axioms(|cons-names))> fs;
			axioms2 := <conc> (axioms, fs-axioms); 
			others := <generate-fof-goals(|axioms2, cons)> rest
	generate-fof-goals(|axioms, cons) : [Import(m) | rest] -> others
		where
			Module(_, imps, body) := <get-module-ref> m;
			filtered-body := <filter(not(?Goals(_) + ?Local(_)))> body;
			new-rest := <conc> (imps, filtered-body, rest);
			others := <generate-fof-goals(|axioms, cons)> new-rest

	generate-fof-goals(|axioms, cons) = debug(!"generate-fof-goals failed: "); fail

	
	