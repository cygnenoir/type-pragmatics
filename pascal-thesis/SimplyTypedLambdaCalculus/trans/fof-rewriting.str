module fof-rewriting

imports include/STLC
imports libstratego-lib
imports names
imports props


rules
	R : FunctionExpVar(v) -> Var(v)
	R : FunctionExpMeta(Meta(v)) -> Meta(v)
	R : FunctionExpNeq(t1, t2) -> Neq(t1, t2)
	R : FunctionExpEq(t1, t2) -> Eq(t1, t2)
	R : FunctionExpNot(t) -> <make-not> (t)
	R : FunctionExpApp(f, args) -> <make-termapp> (f, args)
	
	R : PremiseList(p) -> p
	R : ConsequenceList(p) -> p
	R : JudgementCons(j1, j2) -> <make-and> (j1, j2)
	R : TypingJudgment(CTX, E, T) -> Pred("tcheck", [CTX, E, T])
	R : ReduceJudgment(e1, e2) -> Pred("reduce", [e1, e2])
	R : FunctionExpJudgment(e) -> e
	R : ExistsJudgment(vars, prop) -> Exists(vars, prop)
	R : ForallJudgment(vars, prop) -> All(vars, prop)
	R : NotJudgment(j) -> <make-not> (j)
	R : OrJudgement(p) -> p
	R : OrEnd(p) -> p
	R : OrCons(p1, p2) -> <make-or> (p1, p2)
	
	// R : Plus(e1, e2) -> TermApp("plus", [e1, e2])
	// R : Rational(e1, e2) -> TermApp("rat", [e1, e2])
	// R : App(e1, e2) -> TermApp("app", [e1, e2])
	// R : FApp(name, es) -> TermApp(name, es)
	// R : Abs(Meta(v), e2, e3) -> TermApp("abs", [Meta(v), e2, e3])
	// R : Abs(e1, e2, e3) -> TermApp("abs", [Var(e1), e2, e3])
	// R : TyFunction(e1, e2) -> TermApp("arrow", [e1, e2])
	// R : TyFuture(e1) -> TermApp("future", [e1])
	// R : TyNat() -> Var("nat")
	// R : TyVar(v) -> Var(v)
	// R : Meta(v) -> Var(v)
	// R : MetaVariable(v) -> v
	R : Var(v) -> Var(v2)
		where v2 := <string-as-chars([to-lower|id])> v
		    ; <not(equal)> (v, v2)
	R : Meta(v) -> Meta(v2)
		where v2 := <string-as-chars([to-upper|id])> v
		    ; <not(equal)> (v, v2)
	
	// R : Fork(x) -> TermApp("fork", [x])
	// R : Join(x) -> TermApp("join", [x])
	// R : Par(x) -> TermApp("par", [x])
	

	
	R : TypingRule(name, CONSEQUENCE) -> TypingRule(True(), name, CONSEQUENCE)
	R : TypingRule(PREMISES, RuleName(_, NAME), CONSEQUENCE) ->
		Formula(NAME, <close-prop> body)
	where
		body := <make-impl> (PREMISES, CONSEQUENCE)
			
			
	compose-formula-p :
		(Formula(N1, P1), Formula(N2, P2)) -> Formula(N, P)
	where
		N := <conc-strings> (N1, " AND ", N2);
		P := <make-and> (P1, P2)
	compose-formula-p = debug(!"compose-formula-p failed: "); fail

	compose-formulas = reduce-list(compose-formula-p)
	
	reduce-list(s) = ?[] <+ ?[<id>] <+ foldr1(s)
	reduce-list(s|init) = (?[];!init) <+ ?[<id>] <+ foldr1(s)

rules
	// lookup-ctx-base = !Formula("lookup ctx base", Axiom(), All([Meta("X"), Meta("T"), Meta("T2"), Meta("CTX")],
	//                      Impl(Pred("lookup", [Meta("X"), TermApp("bind", [Meta("X"), Meta("T2"), Meta("CTX")]), Meta("T")]),
	//                           Eq(Meta("T"), Meta("T2")))))
	// lookup-ctx-step = !Formula("lookup ctx step", Axiom(), All([Meta("X"), Meta("Y"), Meta("T"), Meta("T2"), Meta("CTX")],
	//                      Impl(And(Neq(Meta("X"), Meta("Y")), Pred("lookup", [Meta("X"), Meta("CTX"), Meta("T")])),
	//                           Pred("lookup", [Meta("X"), TermApp("bind", [Meta("Y"), Meta("T2"), Meta("CTX")]), Meta("T")]))))
	// base-rules = ![<lookup-ctx-base>, <lookup-ctx-step>]

	scoped-constructor-axiom = {|Fresh: constructor-axiom|}
	constructor-axiom : ConstructorDecl(name, args, res) -> Formula(ax-name, Axiom(), <make-all> (vars, BiImpl(Eq(t1, t2), arg-eqs-and)))
	where
		ax-name := <conc-strings> ("EQ-", name);
		args1 := <map(?SortRef(<id>); make-fresh; make-meta)> args;
		args2 := <map(?SortRef(<id>); make-fresh; make-meta)> args;
		vars := <conc> (args1, args2);
		t1 := <make-termapp> (name, args1);
		t2 := <make-termapp> (name, args2);
		arg-eqs := <zip; map(\(a1, a2) -> Eq(a1, a2)\)> (args1, args2);
		arg-eqs-and := <reduce-list(\(p1, p2) -> <make-and> (p1, p2)\|True())> arg-eqs
	constructor-axiom = debug(!"constructor-axioms failed: "); fail

	constructor-diff-axioms(|cons) : [] -> []
	constructor-diff-axioms(|cons) : [c|cs] -> <conc> (c-axioms, others)
	where
		c-axioms := <map(\cons-c -> <scoped-constructor-diff-axiom> (cons-c, c)\); filter(not(?None()))> cons;
		new-cons := <conc> (cons, [c]);
		others := <constructor-diff-axioms(|new-cons)> cs
	
	scoped-constructor-diff-axiom = {|Fresh: constructor-diff-axiom|}
	constructor-diff-axiom :
		(ConstructorDecl(old-name, old-args, old-res), ConstructorDecl(new-name, new-args, new-res)) ->
		Formula(ax-name, Axiom(), <make-all> (vars, Neq(old-t, new-t)))
	where
		<equal> (old-res, new-res);
		ax-name := <conc-strings> ("DIFF-",old-name,"-",new-name);
		old-vars := <map(?SortRef(<id>); make-fresh; make-meta)> old-args;
		new-vars := <map(?SortRef(<id>); make-fresh; make-meta)> new-args;
		vars := <conc> (old-vars, new-vars);
		old-t := <make-termapp> (old-name, old-vars);
		new-t := <make-termapp> (new-name, new-vars)
	constructor-diff-axiom :
		(ConstructorDecl(old-name, old-args, old-res), ConstructorDecl(new-name, new-args, new-res)) ->
		None()
	where
		<not(equal)> (old-res, new-res)
	constructor-diff-axiom = debug(!"constructor-diff-axiom failed: "); fail
		
		
	scoped-function-axioms(|cons) = {|Fresh: function-axioms(|cons)|}
	function-axioms(|cons) : FunctionDef(FunctionSig(_,arg-types,res-type), eqs) -> result
	where
		arg-vars := <map(?SortRef(<id>); make-fresh; make-meta)> arg-types;
		datas := <function-eqs-datas(|arg-vars, res-type, cons, True())> eqs;
		result := <map(make-function-formula)> datas
	function-axioms(|cons) = debug(!"function-axioms failed: "); fail
	
	function-eqs-datas(|arg-vars, res-type, cons, prepat-prop) : [] -> []
	function-eqs-datas(|arg-vars, res-type, cons, prepat-prop) : [f@FunctionEq(name, pats, exp) | fs] -> result
	where
		pat-props :=  <map(function-pat-prop(|cons))> pats;
		pat-bind-props := <zip; map(\(a,b) -> Eq(a,b)\)> (arg-vars, pat-props);
		pat-prop := <reduce-list(\(p1, p2) -> <make-and> (p1, p2)\|True())> pat-bind-props;
		pat-notprepat-prop := <make-and> (pat-prop, prepat-prop);
		function-data := <function-eq-data(|arg-vars, res-type, cons, pat-notprepat-prop)> f;
		rest-data := <function-eqs-datas(|arg-vars, res-type, cons, <make-and> (<close-prop(|arg-vars)> <make-not> (pat-prop), prepat-prop))> fs;
		result := <conc> (function-data, rest-data)
	function-eqs-datas(|arg-vars, res-type, cons, prepat-prop) = where(<strip-annos;debug(!"function-eqs-datas failed: ")> (arg-vars, res-type, cons, prepat-prop, <id>)); fail
	
	function-eq-data(|arg-vars, res-type, cons, pat-prop) : FunctionEq(name, pats, exp) -> result
	where
		<not(?RelBool() + ?SortRef("Bool"))> res-type;
		result-term := <make-termapp> (name, arg-vars);
		result-var := Meta("RESULT");
		result-bind := Eq(result-var, result-term);
		exp-props := <function-exp-props(|cons)> exp;
		result := <map(!(name, pat-prop, result-bind, result-var, <id>))> exp-props
	function-eq-data(|arg-vars, res-type, cons, pat-prop) : FunctionEq(name, pats, exp) -> result
	where
		<?RelBool() + ?SortRef("Bool")> res-type;
		result-term := <make-termapp> (name, arg-vars);
		exp-props := <function-exp-props(|cons)> exp;
		result := <map(!(name, pat-prop, True(), result-term{res-type}, <id>))> exp-props
	function-eq-data(|arg-vars, res-type, cons, pat-prop) = debug(!"function-eq-axioms failed: "); fail
	
	function-pat-prop(|cons) : FunctionPatVar(v) -> <make-var> v
	where <elem(|v)> cons
	function-pat-prop(|cons) : FunctionPatVar(v) -> <make-meta> v
	where <not(elem(|v))> cons
	
	function-pat-prop(|cons) : FunctionPatApp(f, ts) -> <make-termapp> (f, args)
	where
		args := <map(function-pat-prop(|cons))> ts
	function-pat-prop(|cons) = debug(!"function-pat-prop failed: "); fail
	
	function-exp-props(|cons) : FunctionExpUndefined() -> []
	function-exp-props(|cons) : FunctionExpTrue() -> [(True(), True())]
	function-exp-props(|cons) : FunctionExpFalse() -> [(True(), False())]
	function-exp-props(|cons) : FunctionExpVar(v) -> [(True(),<make-var> v)]
	where <elem(|v)> cons
	function-exp-props(|cons) : FunctionExpVar(v) -> [(True(),<make-meta> v)]
	where <not(elem(|v))> cons
	function-exp-props(|cons) : FunctionExpIf(c, t, e) -> <conc> (result1, result2)
	where
		[(True(), c-prop)] := <function-exp-props(|cons)> c; // TODO support conditionals in condition
		t-props := <function-exp-props(|cons)> t;
		e-props := <function-exp-props(|cons)> e;
		result1 := <map(\(a,b) -> (<make-and> (c-prop,a), b)\)> t-props;
		result2 := <map(\(a,b) -> (<make-and> (<make-not> (c-prop),a), b)\)> e-props
	function-exp-props(|cons) : FunctionExpLet(x, e1, e2) -> res-props
	where
		var := <make-meta> x;
		[(True(), e1-prop)] := <function-exp-props(|cons)> e1; // TODO support conditionals in bound expression
		eq-prop := Eq(var, e1-prop);
		e2-props := <function-exp-props(|cons)> e2;
		res-props := <map(\(c,p) -> (<make-and> (eq-prop, c), p)\)> e2-props
	function-exp-props(|cons) : FunctionExpEq(e1, e2) -> [(True(), Eq(e1-prop, e2-prop))]
	where
		[(True(), e1-prop)] := <function-exp-props(|cons)> e1; // TODO support conditionals in operands
		[(True(), e2-prop)] := <function-exp-props(|cons)> e2; // TODO support conditionals in operands
		id
	function-exp-props(|cons) : FunctionExpNeq(e1, e2) -> [(True(), Neq(e1-prop, e2-prop))]
	where
		[(True(), e1-prop)] := <function-exp-props(|cons)> e1; // TODO support conditionals in operands
		[(True(), e2-prop)] := <function-exp-props(|cons)> e2; // TODO support conditionals in operands
		id
	function-exp-props(|cons) : FunctionExpAnd(e1, e2) -> [(True(), <make-and> (e1-prop, e2-prop))]
	where
		[(True(), e1-prop)] := <function-exp-props(|cons)> e1; // TODO support conditionals in operands
		[(True(), e2-prop)] := <function-exp-props(|cons)> e2; // TODO support conditionals in operands
		id
	function-exp-props(|cons) : FunctionExpOr(e1, e2) -> [(True(), <make-or> (e1-prop, e2-prop))]
	where
		[(True(), e1-prop)] := <function-exp-props(|cons)> e1; // TODO support conditionals in operands
		[(True(), e2-prop)] := <function-exp-props(|cons)> e2; // TODO support conditionals in operands
		id
	function-exp-props(|cons) : FunctionExpNot(e) -> [(True(), <make-not> (e-prop))]
	where
		[(True(), e-prop)] := <function-exp-props(|cons)> e; // TODO support conditionals in operands
		id
	function-exp-props(|cons) : FunctionExpApp(f, es) -> [(True(), <make-termapp> (f, es-props))]
	where
		es-props := <map(function-exp-props(|cons); ?[(True(), <id>)])> es // TODO support conditionals as function arguments
	function-exp-props(|cons) = debug(!"function-exp-props(|name, pat-props) failed: "); fail

	make-function-formula : 
		(name, pat-prop, result-bind, result-var, (cond, p)) ->
		Formula(fname, Axiom(), <close-prop> body)
	where
		fname := <make-fresh> name;
		body := <make-impl>(pat-prop, <make-impl>(cond, <make-impl>(result-bind, <make-eq> (result-var, p))))
	make-function-formula = debug(!"make-function-formula failed: "); fail
	
	scoped-function-inversion-axioms(|cons) = {|Fresh: function-inversion-axioms(|cons)|}
	function-inversion-axioms(|cons) : FunctionDef(FunctionSig(name,arg-types,res-type), []) -> []
	function-inversion-axioms(|cons) : FunctionDef(FunctionSig(name,arg-types,res-type), eqs) -> [axiom]
	where
		arg-vars := <map(?SortRef(<id>); make-fresh; make-meta)> arg-types;
		result-var := Meta("RESULT");
		result-prop := Eq(TermApp(name, arg-vars), result-var);
		datas := <function-eqs-datas(|arg-vars, res-type, cons, True())> eqs;
		disjuncts := <map(make-function-inversion-disjunct; close-prop-existential(|[result-var|arg-vars]))> datas;
		function-eq-prop := <reduce-list(\(a,b) -> <make-or> (a,b)\)> disjuncts;
		body := <make-impl>(result-prop, function-eq-prop);
		fname := <conc-strings> (name, "-", "INV");
		axiom := Formula(fname, Axiom(), <close-prop> body)
	function-inversion-axioms(|cons) = debug(!"function-inversion-axioms(|cons) failed: "); fail 
	
	make-function-inversion-disjunct : 
		(name, pat-prop, result-bind, result-var, (cond, p)) -> body
	where
		body := <make-and> (pat-prop, <make-and> (cond, <make-eq> (result-var, p)))
	
	crossproduct : ([], ys) -> []
	crossproduct : (xs, []) -> []
	crossproduct : ([x|xs], ys) -> <conc> (<map(\ y -> (x,y)\)> ys, <crossproduct> (xs, ys))
	
	elem(|t) = where(!(<strip-annos> t, <id>); elem)
	
	put-type(|t) = ?term; !term{t}

strategies
	to-prop = innermost(R)
	fof-trans = generate-fof-goals
	
	generate-fof-goals : Module(_, imps, body) -> <conc; {| Imported: generate-fof-goals(|[], []) |}> (imps, body) 
	
	generate-fof-goals(|axioms, cons) : [] -> []
	generate-fof-goals(|axioms, cons) : [Axioms(fs) | rest] -> others
		where
			newAxioms := <to-prop; map(\Formula(name,body) -> Formula(name, Axiom(), body)\)> fs;
			axioms2 := <conc> (axioms, newAxioms); 
			others := <generate-fof-goals(|axioms2, cons)> rest
	generate-fof-goals(|axioms, cons) : [Goals(fs) | rest] -> [goal | others]
		where
			formula := <to-prop; compose-formulas> fs;
			conjecture := <\Formula(name,body) -> Formula(name, Conjecture(), body)\> formula;
			goal := FOFGoal(axioms, conjecture);
			others := <generate-fof-goals(|axioms, cons)> rest
	generate-fof-goals(|axioms, cons) : [Local(xs) | rest] -> <conc> (goals,  others)
		where
			goals := <generate-fof-goals(|axioms, cons)> xs;
			others := <generate-fof-goals(|axioms, cons)> rest
	generate-fof-goals(|axioms, cons) : [Sorts(xs) | rest] -> others
		where
			others := <generate-fof-goals(|axioms, cons)> rest
	generate-fof-goals(|axioms, cons) : [Constructors(cs) | rest] -> others
		where
			cs-axioms := <map(scoped-constructor-axiom)> cs;
			cs-diff-axioms := <constructor-diff-axioms(|cons)> cs;
			axioms2 := <conc> (axioms, cs-axioms, cs-diff-axioms); 
			cons2 := <conc> (cons, cs);
			others := <generate-fof-goals(|axioms2, cons2)> rest
	generate-fof-goals(|axioms, cons) : [Consts(cs) | rest] -> others
		where
			cs-axioms := <map(scoped-constructor-axiom)> cs;
			axioms2 := <conc> (axioms, cs-axioms); 
			cons2 := <conc> (cons, cs);
			others := <generate-fof-goals(|axioms2, cons2)> rest
	generate-fof-goals(|axioms, cons) : [Functions(fs) | rest] -> others
		where
			cons-names := <map(?ConstructorDecl(<id>, _, _); strip-annos)> cons;
			debug;
			fs-axioms := <mapconcat(scoped-function-axioms(|cons-names))> fs;
			debug;
			fs-inv-axioms := <mapconcat(scoped-function-inversion-axioms(|cons-names); debug)> fs;
			debug;
			axioms2 := <conc> (axioms, fs-axioms, fs-inv-axioms);
			debug; 
			others := <generate-fof-goals(|axioms2, cons)> rest
	generate-fof-goals(|axioms, cons) : [Import(m, annos) | rest] -> others
		where
			mname := <strip-annos> m;
			<not(Imported)> mname;
			rules(Imported :+ mname -> mname);
			Module(_, imps, body) := <get-module-ref> m;
			filtered-body := <filter-import(|annos)> body;
			new-rest := <conc> (imps, filtered-body, rest);
			// <debug(!"import: ")> mname;
			others := <generate-fof-goals(|axioms, cons)> new-rest
	generate-fof-goals(|axioms, cons) : [Import(m, annos) | rest] -> others
		where
			mname := <strip-annos> m;
			// <debug(!"skip import: ")> mname;
			others := <generate-fof-goals(|axioms, cons)> rest

	generate-fof-goals(|axioms, cons) = debug(!"generate-fof-goals failed: "); fail

	filter-import(|annos) : xs -> <filter(not(?Goals(_) + ?Local(_)))> xs
	where <?None()> annos
	filter-import(|annos) : [] -> []
	filter-import(|annos) : [x@Axioms(_)|xs] -> [x|<filter-import(|annos)>xs]
	where <?Some(<elem(|ImportAnnoAxioms())>)> annos
	filter-import(|annos) : [x@Goals(_)|xs] -> [x|<filter-import(|annos)>xs]
	where <?Some(<elem(|ImportAnnoGoals())>)> annos
	filter-import(|annos) : [x@Local(_)|xs] -> [x|<filter-import(|annos)>xs]
	where <?Some(<elem(|ImportAnnoGoals())>)> annos
	filter-import(|annos) : [x@Constructors(_)|xs] -> [x|<filter-import(|annos)>xs]
	where <?Some(<elem(|ImportAnnoConstructors())>)> annos
	filter-import(|annos) : [x@Consts(_)|xs] -> [x|<filter-import(|annos)>xs]
	where <?Some(<elem(|ImportAnnoConstructors())>)> annos
	filter-import(|annos) : [x@Functions(_)|xs] -> [x|<filter-import(|annos)>xs]
	where <?Some(<elem(|ImportAnnoFunctions())>)> annos
	filter-import(|annos) : [x|xs] -> <filter-import(|annos)>xs
	
	
	
	