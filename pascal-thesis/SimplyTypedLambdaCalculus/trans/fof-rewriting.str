module fof-rewriting

imports include/STLC
imports libstratego-lib

signature
	sorts Prop FOF File
	constructors
		// Constructors that are commented are currently not used.
		//False : Prop
    	//True  : Prop
    	Atom  : String -> Prop
    	//Not   : Prop -> Prop
    	//And   : Prop * Prop -> Prop
    	//Or    : Prop * Prop -> Prop
    	Impl  : List(Prop) * Prop -> Prop
    	//Eq    : Prop * Prop -> Prop
    	Neq : Prop * Prop -> Prop
    	Var   : String -> Prop
    	Pred  : String * List(Prop) -> Prop //TODO: Make this more typesafe 
    	All   : List(Var) * Prop -> Prop
    	Exists : List(Var) * Prop -> Prop
    	
    	Axiom : Type
    	Conjecture : Type
    	Formula : String * Type * Prop -> FOF
    	
    	File : List(Formula) * List(Formula) -> File

rules
	R : Module(_, Rules(R), Some(DerivedRules(DR))) -> File(R, <map(T)> DR)
	R : Module(_, Rules(R), Some(DerivedRules(DR))) -> File(R, [])
	
	R : CtxEmpty() -> Pred("empty", [])
	R : CtxBindVar(ID, TYPE, CTX) -> Pred("bind", [ID, TYPE, CTX])
	
	
	R : TypingJudgment(CTX, E, T) -> Pred("tcheck", [CTX, E, T])
	R : VarInContextJudgment(ID, TYPE, CTX) -> Pred("lookup", [ID, CTX, TYPE])
	
	R : TypingRule(RuleName(_, NAME), CONSEQUENCE) -> Formula(NAME, Axiom(), All([], CONSEQUENCE))
	R : TypingRule(PREMISES, RuleName(_, NAME), CONSEQUENCE) ->
		Formula(NAME, Axiom(), all-term)
		with
			//TODO: In which cases can meta-variables be bound?
			body := Impl(PREMISES, CONSEQUENCE);
			universalVars := <collect-all(?MetaVariable(_))> PREMISES;
			consequenceVariables := <collect-all(?MetaVariable(_))> CONSEQUENCE;
			exitentialVars := <diff> (consequenceVariables, universalVars);
			exist-term := <make-exists> (exitentialVars, body);
			all-term := <make-all> (universalVars, exist-term)

	make-exists : ([], body) -> body
	make-exists : (vars, body) -> Exists(vars, body)
	make-all : ([], body) -> body
	make-all : (vars, body) -> All(vars, body)
			
	T : Formula(N, _, P) -> Formula(N, Conjecture(), P)

rules
	lookup-ctx-base = !Formula("lookup ctx base", Axiom(), All(["X", "T", "CTX"],
	                     Pred("lookup", [Var("X"), Pred("bind", [Var("X"), Var("T"), Var("CTX")]), Var("T")])))
	lookup-ctx-step = !Formula("lookup ctx step", Axiom(), All(["X", "Y", "T", "T2", "CTX"],
	                     Impl(JudgementCons(Neq("X", "Y"), Pred("lookup", [Var("X"), Var("CTX"), Var("T")])),
	                          Pred("lookup", [Var("X"), Pred("bind", [Var("Y"), Var("T2"), Var("CTX")]), Var("T")]))))
	base-rules = ![<lookup-ctx-base>, <lookup-ctx-step>]

strategies
	main = io-wrap(trans)
	trans = innermost(R); File(\xs -> <conc> (<base-rules>, xs)\, id)
	to-conjecture = T