module fof-rewriting

imports include/STLC
imports libstratego-lib

signature
	sorts Prop FOF File
	constructors
		// Constructors that are commented are currently not used.
		False : Prop
    	True  : Prop
    	// Atom  : String -> Prop
    	//Not   : Prop -> Prop
    	And   : Prop * Prop -> Prop
    	Or    : Prop * Prop -> Prop
    	Impl  : List(Prop) * Prop -> Prop
    	Eq    : Prop * Prop -> Prop
    	Neq : Prop * Prop -> Prop
    	Var   : String -> Prop
    	Pred  : String * List(Prop) -> Prop //TODO: Make this more typesafe
    	TermApp  : String * List(Prop) -> Prop //TODO: Make this more typesafe 
    	All   : List(Var) * Prop -> Prop
    	Exists : List(Var) * Prop -> Prop
    	
    	Axiom : Type
    	Conjecture : Type
    	Formula : String * Type * Prop -> FOF
    	Formula : String * Prop -> FOF
    	
    	FOFGoal : List(Formula) * Formula -> File

rules
	R : CtxEmpty() -> TermApp("empty", [])
	R : CtxBindVar(ID, TYPE, CTX) -> TermApp("bind", [ID, TYPE, CTX])
	
	R : PremiseList(p) -> p
	R : ConsequenceList(p) -> p
	R : JudgementCons(j1, j2) -> And(j1, j2)
	R : TypingJudgment(CTX, E, T) -> Pred("tcheck", [CTX, E, T])
	R : VarInContextJudgment(ID, TYPE, CTX) -> Pred("lookup", [ID, CTX, TYPE])
	R : EqualityJudgementE(t1, t2) -> Eq(t1, t2)
	R : EqualityJudgementT(t1, t2) -> Eq(t1, t2)
	R : EqualityJudgementC(t1, t2) -> Eq(t1, t2)
	R : NotEqualityJudgementE(t1, t2) -> Neq(t1, t2)
	R : NotEqualityJudgementT(t1, t2) -> Neq(t1, t2)
	R : NotEqualityJudgementC(t1, t2) -> Neq(t1, t2)
	R : ExistsJudgment(vars, prop) -> Exists(vars, prop)
	R : OrJudgement(p) -> p
	R : OrEnd(p) -> p
	R : OrCons(p1, p2) -> Or(p1, p2)
	R : ReductionJudgment(e1, e2) -> Pred("reduce", [e1, e2])
	
	R : Plus(e1, e2) -> TermApp("plus", [e1, e2])
	R : Rational(e1, e2) -> TermApp("rat", [e1, e2])
	R : App(e1, e2) -> TermApp("app", [e1, e2])
	R : FApp(name, es) -> TermApp(name, es)
	R : Abs(Meta(v), e2, e3) -> TermApp("abs", [Meta(v), e2, e3])
	R : Abs(e1, e2, e3) -> TermApp("abs", [Var(e1), e2, e3])
	R : TyFunction(e1, e2) -> TermApp("arrow", [e1, e2])
	R : TyFuture(e1) -> TermApp("future", [e1])
	R : TyNat() -> Var("nat")
	R : TyVar(v) -> Var(v)
	// R : Meta(v) -> Var(v)
	R : MetaVariable(v) -> v
	R : Var(v) -> Var(v2)
		where v2 := <string-as-chars(map(to-lower))> v
		    ; <not(equal)> (v, v2)
	R : Meta(v) -> Meta(v2)
		where v2 := <string-as-chars(map(to-upper))> v
		    ; <not(equal)> (v, v2)
	
	R : Fork(x) -> TermApp("fork", [x])
	R : Join(x) -> TermApp("join", [x])
	R : Par(x) -> TermApp("par", [x])
	

	
	R : TypingRule(name, CONSEQUENCE) -> TypingRule(True(), name, CONSEQUENCE)
	R : TypingRule(PREMISES, RuleName(_, NAME), CONSEQUENCE) ->
		Formula(NAME, all-term)
		with
			//TODO: In which cases can meta-variables be bound?
			body := <try(\ Impl(True(), p) -> p \)> Impl(PREMISES, CONSEQUENCE);
			metaVars := <collect-all(?Meta(_))> (PREMISES, CONSEQUENCE);
			existsVars := <collect-all(?ExistsJudgment(<id>,_) + ?Exists(<id>,_)); concat> (PREMISES, CONSEQUENCE);
			universalVars := <diff> (metaVars, existsVars);
			all-term := <make-all> (universalVars, body)

	make-exists : ([], body) -> body
	make-exists : (vars, body) -> Exists(vars, body)
	make-all : ([], body) -> body
	make-all : (vars, body) -> All(vars, body)
			
	compose-formula-p :
		(Formula(N1, P1), Formula(N2, P2)) -> Formula(N, P)
	where
		N := <conc-strings> (N1, " AND ", N2);
		P := And(P1, P2)
	compose-formula-p = debug(!"compose-formula-p failed: "); fail

	compose-formulas = (?[] <+ ?[<id>] <+ foldr1(compose-formula-p))

rules
	// lookup-ctx-base = !Formula("lookup ctx base", Axiom(), All([Meta("X"), Meta("T"), Meta("T2"), Meta("CTX")],
	//                      Impl(Pred("lookup", [Meta("X"), TermApp("bind", [Meta("X"), Meta("T2"), Meta("CTX")]), Meta("T")]),
	//                           Eq(Meta("T"), Meta("T2")))))
	// lookup-ctx-step = !Formula("lookup ctx step", Axiom(), All([Meta("X"), Meta("Y"), Meta("T"), Meta("T2"), Meta("CTX")],
	//                      Impl(And(Neq(Meta("X"), Meta("Y")), Pred("lookup", [Meta("X"), Meta("CTX"), Meta("T")])),
	//                           Pred("lookup", [Meta("X"), TermApp("bind", [Meta("Y"), Meta("T2"), Meta("CTX")]), Meta("T")]))))
	// base-rules = ![<lookup-ctx-base>, <lookup-ctx-step>]

strategies
	main = io-wrap(trans)
	trans = innermost(R)
	fof-trans = trans; generate-fof-goals
	
	generate-fof-goals : Module(_, imps, body) -> <conc; generate-fof-goals(|[])> (imps, body) 
	
	generate-fof-goals(|axioms) : [] -> []
	generate-fof-goals(|axioms) : [Axioms(fs) | rest] -> others
		where
			newAxioms := <map(\Formula(name,body) -> Formula(name, Axiom(), body)\)> fs;
			axioms2 := <conc> (axioms, newAxioms); 
			others := <generate-fof-goals(|axioms2)> rest
	generate-fof-goals(|axioms) : [Goals(fs) | rest] -> [goal | others]
		where
			formula := <compose-formulas> fs;
			conjecture := <\Formula(name,body) -> Formula(name, Conjecture(), body)\> formula;
			goal := FOFGoal(axioms, conjecture);
			others := <generate-fof-goals(|axioms)> rest
	generate-fof-goals(|axioms) = debug(!"generate-fof-goals failed: "); fail

	
	