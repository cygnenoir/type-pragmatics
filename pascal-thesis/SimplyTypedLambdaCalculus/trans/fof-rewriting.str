module fof-rewriting

imports include/STLC
imports libstratego-lib
imports stlc

signature
	sorts Prop FOF File
	constructors
		// Constructors that are commented are currently not used.
		False : Prop
    	True  : Prop
    	// Atom  : String -> Prop
    	//Not   : Prop -> Prop
    	And   : Prop * Prop -> Prop
    	Or    : Prop * Prop -> Prop
    	Impl  : List(Prop) * Prop -> Prop
    	Eq    : Prop * Prop -> Prop
    	Neq : Prop * Prop -> Prop
    	Var   : String -> Prop
    	Pred  : String * List(Prop) -> Prop //TODO: Make this more typesafe
    	TermApp  : String * List(Prop) -> Prop //TODO: Make this more typesafe 
    	All   : List(Var) * Prop -> Prop
    	Exists : List(Var) * Prop -> Prop
    	
    	Axiom : Type
    	Conjecture : Type
    	Formula : String * Type * Prop -> FOF
    	
    	File : List(Formula) * List(Formula) -> File

rules
	R : Module(_, Rules(R), Some(DerivedRules(DR))) -> File(R, DR)
	R : Module(_, Rules(R), None()) -> File(R, [])
	
	R : CtxEmpty() -> TermApp("empty", [])
	R : CtxBindVar(ID, TYPE, CTX) -> TermApp("bind", [ID, TYPE, CTX])
	
	R : PremiseList(p) -> p
	R : ConsequenceList(p) -> p
	R : JudgementCons(j1, j2) -> And(j1, j2)
	R : TypingJudgment(CTX, E, T) -> Pred("tcheck", [CTX, E, T])
	R : VarInContextJudgment(ID, TYPE, CTX) -> Pred("lookup", [ID, CTX, TYPE])
	R : EqualityJudgement(t1, t2) -> Eq(t1, t2)
	R : OrJudgementCons(j1, j2) -> Or(j1, j2)
	R : ExistsJudgment(vars, prop) -> Exists(vars, prop)
	
	R : Plus(e1, e2) -> TermApp("plus", [e1, e2])
	R : Rational(e1, e2) -> TermApp("rat", [e1, e2])
	R : App(e1, e2) -> TermApp("app", [e1, e2])
	R : Abs(Meta(v), e2, e3) -> TermApp("abs", [Meta(v), e2, e3])
	R : Abs(e1, e2, e3) -> TermApp("abs", [Var(e1), e2, e3])
	R : TyFunction(e1, e2) -> TermApp("arrow", [e1, e2])
	R : TyFuture(e1) -> TermApp("future", [e1])
	R : TyNat() -> Var("nat")
	R : TyVar(v) -> Var(v)
	// R : Meta(v) -> Var(v)
	R : MetaVariable(Meta(v)) -> Meta(v2) where v2 := <string-as-chars(map(to-upper))> v
	R : Var(v) -> Var(v2)
		where v2 := <string-as-chars(map(to-lower))> v
		    ; <not(equal)> (v, v2)
	
	R : Fork(x) -> TermApp("fork", [x])
	R : Join(x) -> TermApp("join", [x])
	R : Par(x) -> TermApp("par", [x])
	

	
	R : TypingRule(name, CONSEQUENCE) -> TypingRule(True(), name, CONSEQUENCE)
	R : TypingRule(PREMISES, RuleName(_, NAME), CONSEQUENCE) ->
		Formula(NAME, Axiom(), all-term)
		with
			//TODO: In which cases can meta-variables be bound?
			body := <try(\ Impl(True(), p) -> p \)> Impl(PREMISES, CONSEQUENCE);
			universalVars := <collect-all(?Meta(_))> (PREMISES, CONSEQUENCE);
			all-term := <make-all> (universalVars, body)

	make-exists : ([], body) -> body
	make-exists : (vars, body) -> Exists(vars, body)
	make-all : ([], body) -> body
	make-all : (vars, body) -> All(vars, body)
			
	T : Formula(N, _, P) -> Formula(N, Conjecture(), P)
	
	compose-formulas :
		(Formula(N1, kind, P1), Formula(N2, kind, P2)) ->
		Formula(N, kind, P)
	where
		N := <conc-strings> (N1, " AND ", N2);
		P := And(P1, P2)
	compose-formulas = debug(!"compose-formulas failed: "); fail

	compose-conjectures = (?[] <+ ?[<id>] <+ foldr1(compose-formulas))

rules
	lookup-ctx-base = !Formula("lookup ctx base", Axiom(), All([Meta("X"), Meta("T"), Meta("CTX")],
	                     Pred("lookup", [Meta("X"), TermApp("bind", [Meta("X"), Meta("T"), Meta("CTX")]), Meta("T")])))
	lookup-ctx-step = !Formula("lookup ctx step", Axiom(), All([Meta("X"), Meta("Y"), Meta("T"), Meta("T2"), Meta("CTX")],
	                     Impl(And(Neq(Meta("X"), Meta("Y")), Pred("lookup", [Meta("X"), Meta("CTX"), Meta("T")])),
	                          Pred("lookup", [Meta("X"), TermApp("bind", [Meta("Y"), Meta("T2"), Meta("CTX")]), Meta("T")]))))
	base-rules = ![<lookup-ctx-base>, <lookup-ctx-step>]

strategies
	main = io-wrap(trans)
	trans = innermost(R); File(\xs -> <conc> (<base-rules>, xs)\, map(to-conjecture))
	fof-trans = trans; File(id, compose-conjectures)
	to-conjecture = T