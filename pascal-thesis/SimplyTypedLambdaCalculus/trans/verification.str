module verification

imports
  libstratego-lib
  libstratego-gpp
  libstratego-aterm
  include/STLC
  generate
  names
  fof-rewriting
  smt-rewriting
  stlc
  lib/editor-common.generated
  runtime/analysis/core
  lib/runtime/index/core
  lib/runtime/task/core

signature constructors
	VerificationSuccess : List(Lemmas) -> Result
	VerificationFailure : String -> Result

rules
	CurrentFileFOF = CurrentFile; guarantee-extension(|"fof")
	
	constraint-warning :
		Module(_,_,body) -> <map(\(r,_) -> (r,msg)\)> filtered-results
	where
		rulez := <collect-all(?Goals(<filter(?TypingRule(_,RuleName(_,<id>),_))>)); concat> body;
		outfiles := <generate-file-names(|<CurrentFileFOF>)> rulez;
		results := <map(get-verification-result-info <+ !())> outfiles;
		filtered-results := <zip; filter(?(_,()))> (rulez, results);
		msg := $[Verification result outdated or not started yet, use verification menu to re-verify.]
	
	constraint-note :
		Module(_,_,body) -> <map(\(r,res) -> (r,<verification-success-msg> res)\)> filtered-results
	where
		rulez := <collect-all(?Goals(<filter(?TypingRule(_,RuleName(_,<id>),_))>)); concat> body;
		outfiles := <generate-file-names(|<CurrentFileFOF>)> rulez;
		results := <map(get-verification-result-info <+ !())> outfiles;
		filtered-results := <zip; filter(?(_,VerificationSuccess(_)))> (rulez, results)
	
	verification-success-msg : 
		VerificationSuccess(lemmas) -> 
		$[Verification succeeded, used lemmas: [<separate-by(|", "); concat-strings> lemmas].]
	
	
	constraint-error : 
		Module(_,_,body) -> <map(\(r,res) -> (r,<verification-failure-msg> res)\)> filtered-results
	where
		rulez := <collect-all(?Goals(<filter(?TypingRule(_,RuleName(_,<id>),_))>)); concat> body;
		outfiles := <generate-file-names(|<CurrentFileFOF>)> rulez;
		results := <map(get-verification-result-info <+ !())> outfiles;
		filtered-results := <zip; filter(?(_,VerificationFailure(_)))> (rulez, results)

	verification-failure-msg : 
		VerificationFailure(errmsg) -> $[Verification failed: [errmsg].]

rules
	clean-proofs : (selected, position, ast, path, project-path) -> None()
	where
		index-setup(|<language>, project-path);
		task-setup(|project-path);
	    filename := <guarantee-extension(|"fof")> path;
	    rulez := <collect-all(?Goals(<filter(?TypingRule(_,RuleName(_,<id>),_))>)); concat> ast;
	    outfiles := <generate-file-names(|filename)> rulez;
	    <map(clean-proof)> outfiles
	
	clean-proof =
		?file;
		fof-file := <guarantee-extension(|"fof")> file;
		hash-file := <guarantee-extension(|"hash")> file;
		info-file := <guarantee-extension(|"info")> file;
		proof-file := <guarantee-extension(|"proof")> file;
		<try(remove-file)> fof-file;
		<try(remove-file)> hash-file;
		<try(remove-file)> info-file;
		<try(remove-file)> proof-file
	

rules
	verify-vampire :
		input@(selected, position, ast, path, project-path) -> None()
	where
		index-setup(|<language>, project-path);
		task-setup(|project-path);
	    filename := <guarantee-extension(|"fof")> path;
	    rulez := <collect-all(?Goals(<filter(?TypingRule(_,RuleName(_,<id>),_))>)); concat> ast;
	    goals := <fof-trans <+ error(!"fof-trans failed: ")> ast;
	    strings := <map(pp-formula <+ pp-debug(pp-formula))> goals;
	    outfiles := <generate-files(|filename)> strings;
	    <zip; map(\(r,f) -> <try(call-vampire)> f\)> (rulez, outfiles);
    	<queue-analysis> path
	

	// call-and-handle = call < debug(!"Command succeeded: ") + debug(!"Command failed: ")

	call-vampire(|partition, rule) = 
		?file;
		proof-file := <guarantee-extension(|"proof")> file;
		if <not-up-to-date> file => (hash-file, new-hash)
		then <write-file> (hash-file, new-hash);
			 Stream(ins) := <stdin-stream>;
    		 Stream(out) := <fopen> (proof-file, "w");
    		 Stream(err) := <stderr-stream>;
			 finally(
				<call> (<vampire-command>, <conc>(<vampire-options>, [file]), ins, out, err),
				<fclose> out;
				<extract-vampire-info> proof-file
				)
		else <extract-vampire-info> proof-file
		end
	
	not-up-to-date = 
		?file;
		proof-file := <guarantee-extension(|"proof")> file;
		hash-file := <guarantee-extension(|"hash")> file;
		new-hash := <compute-hash> file;
		(  <not(file-exists)> proof-file 
		<+ <not(file-exists)> hash-file
		<+ old-hash := <read-text-file <+ !""> hash-file;
		   <not(equal)> (new-hash, old-hash)
		);
		!(hash-file, new-hash)
		
		
	extract-vampire-info =
		?proof-file;
		proof := <read-text-file> proof-file;
		lines := <get-lines; reverse; ?[_,last,butlast|_]; reverse> proof;
		lemma-lines := <filter(string-starts-with(|"  file("))> lines;
		lemmas := <map(extract-tptp-lemma-name-from-line)> lemma-lines;
		info-file := <guarantee-extension(|"info")> proof-file;
		result := <is-substring(!"Success") <
			        !VerificationSuccess(lemmas) + 
			        !VerificationFailure(butlast)> last;
		<write-file> (info-file, <write-to-string> result)
	
	get-verification-result-info =
		?file;
		not(not-up-to-date);
		info-file := <guarantee-extension(|"info")> file;
		<read-text-file; read-from-string> info-file
		
	
	extract-tptp-lemma-name-from-line =
		?line;
		<split-after; Snd> (line, ",");
		<split-before; Fst> (<id>, ")");
		try(unquote(?'\''))

	compute-hash =
		?file;
		<not(file-exists)> file;
		!0
	compute-hash =
		?file;
		(tmp,_) := <new-temp-file>;
		<call> (<hash-command>, <conc> (<hash-options(|tmp)>, [file]));
		<read-text-file> tmp

	
	vampire-command = !"/Users/seba/Library/bin/vampire"
	vampire-options = vampire-options(|"60")
	vampire-options(|time) =
		!["-t", time, 
	      "--mode", "casc",
	      "--proof", "tptp",
	      "--output_axiom_names", "on"]

	hash-command = !"openssl"
	hash-options(|out) = 
		!["md5", "-out", out]
		
		
