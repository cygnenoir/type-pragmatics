module verification

imports
  libstratego-lib
  libstratego-gpp
  libstratego-aterm
  include/STLC
  generate
  names
  fof-rewriting
  smt-rewriting
  lib/editor-common.generated
  lib/runtime/index/core
  lib/runtime/task/core

signature constructors
	VerificationSuccess : File * List(Lemmas) -> Result
	VerificationFailure : File * String -> Result

rules
	constraint-warning :
		RuleName(_, r) -> (r, msg)
	where
		VerificationSuccess(file, lemmas) := <get-verification-result> r;
		<not-up-to-date> file;
		msg := $[Verification result outdated, use verification menu to re-verify.]
	
	constraint-warning :
		Goals(rs) -> msgs
	where
		need-update := <filter(?TypingRule(_,RuleName(_,<id>),_); not(get-verification-result))> rs;
		msg := $[Verification result outdated, use verification menu to re-verify.];
		msgs := <map(\r -> (r, msg)\)> need-update
	
	
	constraint-note :
		RuleName(_, r) -> (r, msg)
	where
		VerificationSuccess(file, lemmas) := <get-verification-result> r;
		<not(not-up-to-date)> file;
		msg := $[Verification succeeded, used lemmas: [<separate-by(|", "); concat-strings> lemmas].]
	
	
	constraint-error : 
		RuleName(_, r) -> (r, msg)
	where
		VerificationFailure(file, errmsg) := <get-verification-result> r;
		<not(not-up-to-date)> file;
		msg := $[Verification failed: [errmsg].]

rules
	clean-proofs : (selected, position, ast, path, project-path) -> None()
	where
		index-setup(|<language>, project-path);
		task-setup(|project-path);
	    filename := <guarantee-extension(|"fof")> path;
	    goals := <fof-trans <+ error(!"fof-trans failed: ")> ast;
	    strings := <map(pp-formula <+ pp-debug(pp-formula))> goals;
	    outfiles := <generate-files(|filename)> strings;
	    <map(clean-proof)> outfiles
	
	clean-proof =
		?file;
		hash-file := <guarantee-extension(|"hash")> file;
		info-file := <guarantee-extension(|"info")> file;
		proof-file := <guarantee-extension(|"proof")> file;
		<try(remove-file)> hash-file;
		<try(remove-file)> info-file;
		<try(remove-file)> proof-file
	
	
	verify-vampire :
		(selected, position, ast, path, project-path) -> None()
	where finally(
		index-setup(|<language>, project-path);
		task-setup(|project-path);
		partition   := $[[project-path]];
		try(task-start-collection(|partition));
		
	    filename := <guarantee-extension(|"fof")> path;
	    rulez := <collect-all(?Goals(<filter(?TypingRule(_,RuleName(_,<id>),_))>)); concat> ast;
	    goals := <fof-trans <+ error(!"fof-trans failed: ")> ast;
	    strings := <map(pp-formula <+ pp-debug(pp-formula))> goals;
	    outfiles := <generate-files(|filename)> strings;
	    <zip; map(\(r,f) -> <try(call-vampire(|partition, r))> f\)> (rulez, outfiles),
    try(task-stop-collection(|partition)))
	    

	// call-and-handle = call < debug(!"Command succeeded: ") + debug(!"Command failed: ")

	call-vampire(|partition, rule) = 
		?file;
		proof-file := <guarantee-extension(|"proof")> file;
		if <not-up-to-date> file => (hash-file, new-hash)
		then <write-file> (hash-file, new-hash);
			 Stream(ins) := <stdin-stream>;
    		 Stream(out) := <fopen> (proof-file, "w");
    		 Stream(err) := <stderr-stream>;
			 finally(
				<call> (<vampire-command>, <conc>(<vampire-options>, [file]), ins, out, err);
				<extract-vampire-info(|file, partition, rule)> proof-file,
				<fclose> out)
		else <extract-vampire-info(|file, partition, rule)> proof-file
		end
	
	not-up-to-date =
		?file;
		hash-file := <guarantee-extension(|"hash")> file;
		new-hash := <compute-hash> file;
		old-hash := <read-text-file <+ !""> hash-file;
		<not(equal)> (new-hash, old-hash);
		!(hash-file, new-hash)
	
	extract-vampire-info(|file, partition, rule) =
		?proof-file;
		proof := <read-text-file> proof-file;
		lines := <get-lines; reverse; Tl; ?[last,butlast|_]; reverse> proof;
		lemma-lines := <filter(string-starts-with(|"  file("))> lines;
		lemmas := <map(extract-tptp-lemma-name-from-line)> lemma-lines;
		info-file := <guarantee-extension(|"info")> proof-file;
		result := <is-substring(!"Success") <
			        !VerificationSuccess(file, lemmas) + 
			        !VerificationFailure(file, butlast)> last;
		<write-file> (info-file, <write-to-string> result);
		<store-verification-result(|partition, result)> rule
	
	extract-tptp-lemma-name-from-line =
		?line;
		<split-after; Snd> (line, ",");
		<split-before; Fst> (<id>, ")");
		try(unquote(?'\''))

	compute-hash =
		?file;
		(tmp,_) := <new-temp-file>;
		<call> (<hash-command>, <conc> (<hash-options(|tmp)>, [file]));
		<read-text-file> tmp

	
	vampire-command = !"/Users/seba/Library/bin/vampire"
	vampire-options = vampire-options(|"60")
	vampire-options(|time) =
		!["-t", time, 
	      "--mode", "casc",
	      "--proof", "tptp",
	      "--output_axiom_names", "on"]

	hash-command = !"openssl"
	hash-options(|out) = 
		!["md5", "-out", out]
		
		
