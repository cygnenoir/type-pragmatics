module smt-rewriting

imports include/STLC
imports libstratego-lib
imports trans/fof-rewriting

signature
	constructors
		DeclFun : ID * List(Sort) * Sort -> Stmt
		DefFun : ID * List(Tuple(ID, Sort)) * Sort * Expr -> Stmt
		Assert : Prop -> Stmt
		Term : Sort
		Bool : Sort
		SmtList : List(Expr) -> Expr

rules
	main = io-wrap(smt-trans)
	smt-trans = trans; fof-to-smt
	
	fof-to-smt : File(axioms, conjectures) -> <conc> (booldecls, termdecls, assert-defines, asserts)
	where
		preds := <collect-all(?Pred(_,_))> (axioms, conjectures);
		termapps := <collect-all(?TermApp(_,_))> (axioms, conjectures);
		booldecls := <map(pred-to-fun-decl); make-set> preds;
		termdecls := <map(termapp-to-fun-decl); make-set> termapps;
		assert-defines := <map(formula-to-define)> axioms;
		asserts := <map(formula-to-assert)> axioms
	
	pred-to-fun-decl :
		Pred(name,args) -> DeclFun(name, <map(!Term())> args, Bool())
	
	termapp-to-fun-decl :
		TermApp("abs",args) -> <termapp-to-fun-decl> TermApp("fabs", args)
	termapp-to-fun-decl :
		TermApp(name,args) -> DeclFun(name, <map(!Term())> args, Term())
	termapp-to-fun-decl = debug(!"fail: "); fail
	
	formula-to-define :
		Formula(name, _, prop) -> DefFun(<fun-name> name, [], Bool(), <prop-to-smt> prop)
	formula-to-assert :
		Formula(name, _, prop) -> Assert(Var(<fun-name> name))
	fun-name = string-as-chars(map(try(?' ';!	'-')))

rules
	prop-to-smt : Var(v) -> Var(v)
	prop-to-smt : Neq(e1, e2) -> SmtList([Var("distinct"), <prop-to-smt> e1, <prop-to-smt> e2])
	prop-to-smt : TermApp("abs", args) -> <prop-to-smt> TermApp("fabs", args)
	prop-to-smt : Pred(name, args) -> SmtList([Var(name) | <map(prop-to-smt)> args])
	prop-to-smt : TermApp(name, args) -> SmtList([Var(name) | <map(prop-to-smt)> args])
	prop-to-smt : Eq(e1, e2) -> SmtList([Var("="), <prop-to-smt> e1, <prop-to-smt> e2])
	prop-to-smt : And(e1, e2) -> SmtList([Var("and"), <prop-to-smt> e1, <prop-to-smt> e2])
	prop-to-smt : Impl(e1, e2) -> SmtList([Var("=>"), <prop-to-smt> e1, <prop-to-smt> e2])
	prop-to-smt : All(vars, prop) -> SmtList([Var("forall"), SmtList(all-vars), <prop-to-smt> prop])
		where all-vars := <map(\ v -> SmtList([v, Term()]) \)> vars
	prop-to-smt : Exists(vars, prop) -> SmtList([Var("exists"), SmtList(exists-vars), <prop-to-smt> prop])
		where exists-vars := <map(\ v -> SmtList([v, Term()]) \)> vars
	prop-to-smt = debug(!"prop-to-smt failed: "); fail

rules
	pp-smt = 
		map(pp-smt-inner); 
		prepend(|<smt-prelude>);
		map(append-string(|"\n")); 
		concat-strings
	
	pp-smt-inner : 
		DeclFun(name, args, res) -> $[(declare-fun [name] ([<pp-smt-list(|" ")> args]) [<pp-smt-inner> res])]
	pp-smt-inner : 
		DefFun(name, args, res, body) -> $[(define-fun [name] ([<pp-smt-list(|" ")> args]) [<pp-smt-inner> res] [<pp-smt-inner> body])]
	pp-smt-inner :
		Assert(e) -> $[(assert [<pp-smt-inner> e])]
	pp-smt-inner : SmtList(k) -> $[([<pp-smt-list(|" ")> k])]
	pp-smt-inner : Term() -> "Term"
	pp-smt-inner : Bool() -> "Bool"
	pp-smt-inner : Var(v) -> v
	pp-smt-inner = debug(!"pp-smt-inner failed: "); fail
	
	pp-smt-list(|sep) : [] -> ""
	pp-smt-list(|sep) : [arg] -> <pp-smt-inner> arg
	pp-smt-list(|sep) : [arg|args] -> <concat-strings> [<pp-smt-inner> arg, sep, <pp-smt-list(|sep)> args]
	pp-smt-list(|sep) = debug(!"pp-smt-list failed: "); fail

	append-string(|s) = !(<id>, s); conc-strings
	prepend-string(|s) = !(s, <id>); conc-strings

	append(|k) = !(<id>, k); conc
	prepend(|k) = !(k, <id>); conc

rules
	smt-prelude = ![<set-logic>, <decl-term-sort>]
	set-logic = !"" // TODO explicitly set logic
	decl-term-sort = !"(declare-sort Term 0)"
	