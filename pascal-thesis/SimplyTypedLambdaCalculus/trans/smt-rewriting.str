module smt-rewriting

imports include/STLC
imports libstratego-lib
imports trans/fof-rewriting

signature
	constructors
		DeclFun : ID * List(Sort) * Sort -> Stmt
		DefFun : ID * List(Tuple(ID, Sort)) * Sort * Expr -> Stmt
		Assert : Prop -> Stmt
		Term : Sort
		Bool : Sort
		SmtLit : String -> Expr
		SmtList : List(Expr) -> Expr

rules
	main = io-wrap(smt-trans)
	smt-trans = trans; fof-to-smt
	
	fof-to-smt :
		(axioms,conjecture) -> 
		// File(axioms, conjecture) -> 
		<conc> (
			booldecls,
			termdecls, 
			consttermdecls, 
			axiom-defines, 
			smt-axioms, 
			conjecture-defines, 
			conjecture-checks)
	where
		preds := <collect-all(?Pred(_,_))> (axioms, conjecture);
		termapps := <collect-all(?TermApp(_,_))> (axioms, conjecture);
		vars := <collect-all(?Var(_))> (axioms, conjecture);
		booldecls := <map(pred-to-fun-decl); make-set> preds;
		termdecls := <map(termapp-to-fun-decl); make-set> termapps;
		consttermdecls := <map(var-to-fun-decl); make-set> vars;
		axiom-defines := <map(formula-to-define)> axioms;
		smt-axioms := <map(formula-to-assert)> axioms;
		conjecture-defines := <map(formula-to-define)> conjecture;
		conjecture-checks := <mapconcat(conjecture-define-to-check); try(?[];![SmtList([Var("check-sat")])])> conjecture-defines
	fof-to-smt = debug(!"fof-to-smt failed: "); fail
	
	pred-to-fun-decl :
		Pred(name,args) -> DeclFun(name, <map(!Term())> args, Bool())
	pred-to-fun-decl = debug(!"pred-to-fun-decl failed: "); fail
	
	var-to-fun-decl : Var(v) -> <termapp-to-fun-decl> TermApp(<conc-strings> ("const-",v), [])
	
	termapp-to-fun-decl :
		TermApp("abs",args) -> <termapp-to-fun-decl> TermApp("fabs", args)
	termapp-to-fun-decl :
		TermApp(name,args) -> DeclFun(name, <map(!Term())> args, Term())
	termapp-to-fun-decl = debug(!"termapp-to-fun-decl failed: "); fail
	
	formula-to-define :
		Formula(name, prop) -> DefFun(<fun-name> name, [], Bool(), <prop-to-smt> prop)
	formula-to-define = debug(!"formula-to-define failed: "); fail
	
	formula-to-assert :
		Formula(name, prop) -> Assert(Var(<fun-name> name))
	formula-to-assert = debug(!"formula-to-assert failed: "); fail
	fun-name = string-as-chars(map(try(?' ';!	'-')))
	
	conjecture-define-to-check : 
		DefFun(name, _, _, _) -> [push, assert, check, pop] // negated conjecture
	where
		push := SmtList([Var("push"), SmtLit("1")]);
		assert := Assert(SmtList([Var("not"), Var(name)]));
		check := SmtList([Var("check-sat")]);
		pop := SmtList([Var("pop"), SmtLit("1")])
	conjecture-define-to-check = debug(!"conjecture-defines-to-asserts failed: "); fail

rules
	prop-to-smt : True() -> Var("true")
	prop-to-smt : False() -> Var("false")
	prop-to-smt : Var(v) -> Var(<conc-strings> ("const-",v))
	prop-to-smt : Meta(v) -> Meta(v)
	prop-to-smt : Neq(e1, e2) -> SmtList([Var("distinct"), <prop-to-smt> e1, <prop-to-smt> e2])
	prop-to-smt : TermApp("abs", args) -> <prop-to-smt> TermApp("fabs", args)
	prop-to-smt : Pred(name, args) -> SmtList([Var(name) | <map(prop-to-smt)> args])
	prop-to-smt : TermApp(name, args) -> SmtList([Var(name) | <map(prop-to-smt)> args])
	prop-to-smt : Eq(e1, e2) -> SmtList([Var("="), <prop-to-smt> e1, <prop-to-smt> e2])
	prop-to-smt : Or(e1, e2) -> SmtList([Var("or"), <prop-to-smt> e1, <prop-to-smt> e2])
	prop-to-smt : And(e1, e2) -> SmtList([Var("and"), <prop-to-smt> e1, <prop-to-smt> e2])
	prop-to-smt : Impl(e1, e2) -> SmtList([Var("=>"), <prop-to-smt> e1, <prop-to-smt> e2])
	prop-to-smt : All(vars, prop) -> SmtList([Var("forall"), SmtList(all-vars), <prop-to-smt> prop])
		where all-vars := <map(\ v -> SmtList([v, Term()]) \)> vars
	prop-to-smt : Exists(vars, prop) -> SmtList([Var("exists"), SmtList(exists-vars), <prop-to-smt> prop])
		where exists-vars := <map(\ v -> SmtList([v, Term()]) \)> vars
	prop-to-smt = debug(!"prop-to-smt failed: "); fail

rules
	pp-smt = 
		map(pp-smt-inner); 
		prepend(|<smt-prelude>);
		map(append-string(|"\n")); 
		concat-strings
	
	pp-smt-inner : 
		DeclFun(name, args, res) -> $[(declare-fun [name] ([<pp-smt-list(|" ")> args]) [<pp-smt-inner> res])]
	pp-smt-inner : 
		DefFun(name, args, res, body) -> $[(define-fun [name] ([<pp-smt-list(|" ")> args]) [<pp-smt-inner> res] [<pp-smt-inner> body])]
	pp-smt-inner :
		Assert(e) -> $[(assert [<pp-smt-inner> e])]
	pp-smt-inner : SmtLit(s) -> s
	pp-smt-inner : SmtList(k) -> $[([<pp-smt-list(|" ")> k])]
	pp-smt-inner : Term() -> "Term"
	pp-smt-inner : Bool() -> "Bool"
	pp-smt-inner : Var(v) -> v
	pp-smt-inner : Meta(v) -> v
	pp-smt-inner = debug(!"pp-smt-inner failed: "); fail
	
	pp-smt-list(|sep) : [] -> ""
	pp-smt-list(|sep) : [arg] -> <pp-smt-inner> arg
	pp-smt-list(|sep) : [arg|args] -> <concat-strings> [<pp-smt-inner> arg, sep, <pp-smt-list(|sep)> args]
	pp-smt-list(|sep) = debug(!"pp-smt-list failed: "); fail

	append-string(|s) = !(<id>, s); conc-strings
	prepend-string(|s) = !(s, <id>); conc-strings

	append(|k) = !(<id>, k); conc
	prepend(|k) = !(k, <id>); conc

rules
	smt-prelude = ![<set-logic>, <decl-term-sort>]
	set-logic = !"" // TODO explicitly set logic
	decl-term-sort = !"(declare-sort Term 0)"
	