module STLC

imports Language
%% imports Par

exports 
	lexical syntax
  		"===" "="* -> RuleSep
  		[a-zA-Z0-9\-]+ -> Name
  		
  	lexical restrictions
  		RuleSep -/- [\=]
  		
  	context-free syntax
  		RuleSep Name -> RuleSepName {cons("RuleName"), layout("1.first.line == 2.last.line")}
  		
  	    %% Syntax for typing rules
  		TypingRulePremises RuleSepName TypingRuleConsequences
  			-> TypingRule {cons("TypingRule"), layout("1.first.col == 2.first.col && 2.first.col == 3.first.col && 1.last.line + num(1) == 2.first.line")}
  		RuleSepName TypingRuleConsequences -> TypingRule {cons("TypingRule"), layout("1.first.col == 2.first.col")}
  			
  		TypingRuleJudgementList -> TypingRulePremises {cons("PremiseList")}
  		
  		TypingRuleJudgementList -> TypingRuleConsequences  {cons("ConsequenceList")}
  		
  		OffTypingRuleJudgment -> TypingRuleJudgementList
  		OffTypingRuleJudgment TypingRuleJudgementList -> TypingRuleJudgementList {cons("JudgementCons"),
  									   									   layout("1.first.col == 2.first.col && 2.first.line - 1.last.line == num(1)")}
  																			   
  		TypingRuleJudgment -> OffTypingRuleJudgment {layout("1.first.col < 1.left.col")}

		OrTypingRuleJudgement -> OffTypingRuleJudgment
		"OR" OrCaseList -> OrTypingRuleJudgement {cons("OrJudgement")}
		
		"=>" TypingRuleJudgementList -> OrCaseList {cons("OrEnd")}
		"=>" TypingRuleJudgementList OrCaseList -> OrCaseList {cons("OrCons"), layout("1.first.col == 3.first.col")}
  		
	    %% Syntax for typing judgemnts 
		FunctionExp "|-" FunctionExp ":" FunctionExp -> TypingJudgment {cons("TypingJudgment")}
		
		FunctionExp "=" FunctionExp -> EqualityJudgment {cons("EqualityJudgement")}
		
		FunctionExp "!=" FunctionExp -> EqualityJudgment {cons("NotEqualityJudgement")}
		
		"exists" {MetaVar ","}+ TypingRuleJudgementList -> ExistsJudgment {cons("ExistsJudgment"), layout("1.first.col < 3.first.col && 1.first.line < 3.first.line")}
		
		TypingJudgment -> TypingRuleJudgment
		EqualityJudgment -> TypingRuleJudgment
		ExistsJudgment -> TypingRuleJudgment
		
	sorts Module Rules DerivedRules Import Imports ModuleDec Qualified Definitions
	
	lexical syntax
		[a-zA-Z][a-zA-Z0-9]* -> Sort
	lexical restrictions
		Sort -/- [a-zA-Z0-9]
		
	
	context-free syntax
		ID ":" Sort+ "->" Sort -> ConstructorDecl {cons("ConstructorDecl")}
		ConstDecl -> ConstructorDecl
		ID ":" Sort -> ConstDecl {ast("ConstructorDecl(<1>, [], <2>)")}
		
	context-free syntax
		FunctionSig FunctionEq+ -> FunctionDef {cons("FunctionDef")}
		ID ":" Sort+ "->" Sort -> FunctionSig{cons("FunctionSig")}
		ID "=" FunctionExp -> FunctionEq {ast("FunctionEq(<1>, [], <2>)")}
		ID "(" {FunctionPattern ","}* ")" "=" FunctionExp -> FunctionEq {cons("FunctionEq")}
		
		ID -> FunctionExp {cons("FunctionExpVar")}
		"if" FunctionExp "then" FunctionExp "else" FunctionExp -> FunctionExp {cons("FunctionExpIf")}
		ID "(" {FunctionExp ","}* ")" -> FunctionExp {cons("FunctionExpApp")}
		FunctionExp "==" FunctionExp -> FunctionExp {cons("FunctionExpEq")}
		FunctionExp "!=" FunctionExp -> FunctionExp {cons("FunctionExpNeq")}
		"(" FunctionExp ")" -> FunctionExp {bracket}
		MetaVar -> FunctionExp {cons("FunctionExpMeta")}
		"~" ID -> MetaVar {cons("Meta")}
		
		ID -> FunctionPattern {cons("FunctionPatVar")}
		ID "(" {FunctionPattern ","}* ")" -> FunctionPattern {cons("FunctionPatApp")}
	
	context-free syntax
		"import" MID -> Import {cons("Import")}
		
		"local" "{" ModuleDef* "}" -> ModuleDef {cons("Local")}

		"sorts" Sort* -> ModuleDef {cons("Sorts")}
		
		"constructors" ConstructorDecl* -> ModuleDef {cons("Constructors")}
		"constructor" ConstructorDecl -> ModuleDef {ast("Constructors([<1>])")}

		"consts" ConstDecl* -> ModuleDef {cons("Consts")}
		"const" ConstDecl -> ModuleDef {ast("Consts([<1>])")}

		"functions" FunctionDef* -> ModuleDef {cons("Functions")}
		"function" FunctionDef -> ModuleDef {ast("Functions([<1>])")}

		"axioms" TypingRule* -> ModuleDef {cons("Axioms")}
		"axiom" TypingRule -> ModuleDef {ast("Axioms([<1>])")}
		
		"goals" TypingRule* -> ModuleDef {cons("Goals")}
		"goal" TypingRule -> ModuleDef {ast("Goals([<1>])")}
		
		"module" MID Import* ModuleDef*-> Module {cons("Module")}
								
	context-free start-symbols Module
