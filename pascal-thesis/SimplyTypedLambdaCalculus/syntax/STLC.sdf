module STLC

imports Language
imports Par

exports 
	lexical syntax
  		"===" "="* -> RuleSep
  		[a-zA-Z0-9\-]+ -> Name
  		
  	lexical restrictions
  		RuleSep -/- [\=]
  		
  	context-free syntax
  		RuleSep Name -> RuleSepName {cons("RuleName"), "layout(1.first.line = 2.last.line)"}
  		
  	    %% Syntax for typing rules
  		TypingRulePremises RuleSepName TypingRuleConsequences
  			-> TypingRule {cons("TypingRule"), "layout(1.first.col == 2.first.col && 2.first.col == 3.first.col)"}
  		RuleSepName TypingRuleConsequences -> TypingRule {cons("TypingRule"), "layout(1.first.col == 2.first.col)"}
  			
  		TypingRuleJudgementList -> TypingRulePremises {cons("PremiseList")}
  		
  		TypingRuleJudgementList -> TypingRuleConsequences  {cons("ConsequenceList")}
  		OrTypingRuleJudgementList -> TypingRuleConsequences  {cons("ConsequenceList")}
  		
  		OffTypingRuleJudgment -> TypingRuleJudgementList
  		OffTypingRuleJudgment TypingRuleJudgementList -> TypingRuleJudgementList {cons("JudgementCons"),
  									   									   layout("1.first.col == 2.first.col && 2.first.line - 1.last.line == num(1)")}
  																			   
  		TypingRuleJudgment -> OffTypingRuleJudgment {layout("1.first.col < 1.left.col")}

		"OR" TypingRuleJudgementList -> OrTypingRuleJudgementList {layout("1.first.col < 2.first.col")}
		"OR" TypingRuleJudgementList OrTypingRuleJudgementList -> OrTypingRuleJudgementList {"OrJudgementCons", layout("1.first.col < 2.first.col && 1.first.col == 3.first.col")}
  		
  	    %% Syntax for contexts
  		"()" -> Context {cons("CtxEmpty")}
		ID ":" Type ";" Context -> Context {cons("CtxBindVar")}
		Meta ":" Type ";" Context -> Context {cons("CtxBindVar")}
		"(" Context ")" -> Context {bracket}
		Meta -> Context {cons("MetaVariable")}
  		  					  
  					
	    %% Syntax for typing judgemnts 
		Context "|-" Expr ":" Type -> TypingJudgment {cons("TypingJudgment")}
		ID ":" Type "in" Context -> VarInContextJudgment   {cons("VarInContextJudgment")}
		Meta ":" Type "in" Context -> VarInContextJudgment {cons("VarInContextJudgment")}
		
		Expr "=" Expr -> EqualityJudgment {cons("EqualityJudgement"), prefer}
		Type "=" Type -> EqualityJudgment {cons("EqualityJudgement")}
		
		"exists" {Meta ","}+ TypingRuleJudgementList -> ExistsJudgment {cons("ExistsJudgment"), layout("1.first.col < 3.first.col && 1.first.line < 3.first.line")}
		
		TypingJudgment -> TypingRuleJudgment
		VarInContextJudgment  -> TypingRuleJudgment
		EqualityJudgment -> TypingRuleJudgment
		ExistsJudgment -> TypingRuleJudgment
		
	sorts Module Rules DerivedRules Import Imports ModuleDec Qualified Definitions
	
	context-free syntax
		"module" MID -> ModuleDec {cons("ModuleDec")}
		"rules" TypingRule* -> Rules {cons("Rules")}
		"derived-rules" TypingRule* -> DerivedRules {cons("DerivedRules")}
		
		%% TODO: Make derived rules optional
		ModuleDec Rules DerivedRules?-> Module {cons("Module")}						
	context-free start-symbols Module
