module STLC

imports Language
imports Par

exports 
	lexical syntax
  		"===" "="* -> RuleSep
  		[a-zA-Z0-9\-]+ -> Name
  		
  	lexical restrictions
  		RuleSep -/- [\=]
  		
  	context-free syntax
  		RuleSep Name -> RuleSepName {cons("RuleName"), layout("1.first.line == 2.last.line")}
  		
  	    %% Syntax for typing rules
  		TypingRulePremises RuleSepName TypingRuleConsequences
  			-> TypingRule {cons("TypingRule"), layout("1.first.col == 2.first.col && 2.first.col == 3.first.col && 1.last.line + num(1) == 2.first.line")}
  		RuleSepName TypingRuleConsequences -> TypingRule {cons("TypingRule"), layout("1.first.col == 2.first.col")}
  			
  		TypingRuleJudgementList -> TypingRulePremises {cons("PremiseList")}
  		
  		TypingRuleJudgementList -> TypingRuleConsequences  {cons("ConsequenceList")}
  		
  		OffTypingRuleJudgment -> TypingRuleJudgementList
  		OffTypingRuleJudgment TypingRuleJudgementList -> TypingRuleJudgementList {cons("JudgementCons"),
  									   									   layout("1.first.col == 2.first.col && 2.first.line - 1.last.line == num(1)")}
  																			   
  		TypingRuleJudgment -> OffTypingRuleJudgment {layout("1.first.col < 1.left.col")}

		OrTypingRuleJudgement -> OffTypingRuleJudgment
		"OR" OrCaseList -> OrTypingRuleJudgement {cons("OrJudgement")}
		
		"=>" TypingRuleJudgementList -> OrCaseList {cons("OrEnd")}
		"=>" TypingRuleJudgementList OrCaseList -> OrCaseList {cons("OrCons"), layout("1.first.col == 3.first.col")}
  		
  	    %% Syntax for contexts
  		"()" -> Context {cons("CtxEmpty")}
		Var ":" Type ";" Context -> Context {cons("CtxBindVar")}
		Meta ":" Type ";" Context -> Context {cons("CtxBindVar")}
		"(" Context ")" -> Context {bracket}
		Meta -> Context {cons("MetaVariable")}
  		  					  
  					
	    %% Syntax for typing judgemnts 
		Context "|-" Expr ":" Type -> TypingJudgment {cons("TypingJudgment")}
		Var ":" Type "in" Context -> VarInContextJudgment   {cons("VarInContextJudgment")}
		Meta ":" Type "in" Context -> VarInContextJudgment {cons("VarInContextJudgment")}
		
		Expr "=" Expr -> EqualityJudgment {cons("EqualityJudgementE"), prefer}
		Type "=" Type -> EqualityJudgment {cons("EqualityJudgementT")}
		Context "=" Context -> EqualityJudgment {cons("EqualityJudgementC"), avoid}
		
		Expr "!=" Expr -> EqualityJudgment {cons("NotEqualityJudgementE"), prefer}
		Type "!=" Type -> EqualityJudgment {cons("NotEqualityJudgementT")}
		Context "!=" Context -> EqualityJudgment {cons("NotEqualityJudgementC"), avoid}
		
		"exists" {Meta ","}+ TypingRuleJudgementList -> ExistsJudgment {cons("ExistsJudgment"), layout("1.first.col < 3.first.col && 1.first.line < 3.first.line")}
		
		Expr "->" Expr -> ReductionJudgment {cons("ReductionJudgment")}
		
		TypingJudgment -> TypingRuleJudgment
		VarInContextJudgment  -> TypingRuleJudgment
		EqualityJudgment -> TypingRuleJudgment
		ExistsJudgment -> TypingRuleJudgment
		ReductionJudgment -> TypingRuleJudgment
		
	sorts Module Rules DerivedRules Import Imports ModuleDec Qualified Definitions
	
	context-free syntax
		"module" MID -> ModuleDec {cons("ModuleDec")}
		"rules" TypingRule* -> Rules {cons("Rules")}
		"derived-rules" TypingRule* -> DerivedRules {cons("DerivedRules")}
		
		%% TODO: Make derived rules optional
		ModuleDec Rules DerivedRules?-> Module {cons("Module")}						
	context-free start-symbols Module
