module STLC

imports Language
imports Par

exports 
	lexical syntax
  		"===" "="* -> RuleSep
  		[a-zA-Z0-9\-]+ -> Name
  		
  	lexical restrictions
  		RuleSep -/- [\=]
  		
  	context-free syntax
  		RuleSep Name -> RuleSepName {cons("RuleName"), layout("1.first.line == 2.last.line")}
  		
  	    %% Syntax for typing rules
  		TypingRulePremises RuleSepName TypingRuleConsequences
  			-> TypingRule {cons("TypingRule"), layout("1.first.col == 2.first.col && 2.first.col == 3.first.col && 1.last.line + num(1) == 2.first.line")}
  		RuleSepName TypingRuleConsequences -> TypingRule {cons("TypingRule"), layout("1.first.col == 2.first.col")}
  			
  		TypingRuleJudgementList -> TypingRulePremises {cons("PremiseList")}
  		
  		TypingRuleJudgementList -> TypingRuleConsequences  {cons("ConsequenceList")}
  		
  		OffTypingRuleJudgment -> TypingRuleJudgementList
  		OffTypingRuleJudgment TypingRuleJudgementList -> TypingRuleJudgementList {cons("JudgementCons"),
  									   									   layout("1.first.col == 2.first.col && 2.first.line - 1.last.line == num(1)")}
  																			   
  		TypingRuleJudgment -> OffTypingRuleJudgment {layout("1.first.col < 1.left.col")}

		OrTypingRuleJudgement -> OffTypingRuleJudgment
		"OR" OrCaseList -> OrTypingRuleJudgement {cons("OrJudgement")}
		
		"=>" TypingRuleJudgementList -> OrCaseList {cons("OrEnd")}
		"=>" TypingRuleJudgementList OrCaseList -> OrCaseList {cons("OrCons"), layout("1.first.col == 3.first.col")}
  		
  	    %% Syntax for contexts
  		"()" -> Context {cons("CtxEmpty")}
		Var ":" Type ";" Context -> Context {cons("CtxBindVar")}
		Meta ":" Type ";" Context -> Context {cons("CtxBindVar")}
		"(" Context ")" -> Context {bracket}
		Meta -> Context {cons("MetaVariable")}
  		  					  
  					
	    %% Syntax for typing judgemnts 
		Context "|-" Expr ":" Type -> TypingJudgment {cons("TypingJudgment")}
		Var ":" Type "in" Context -> VarInContextJudgment   {cons("VarInContextJudgment")}
		Meta ":" Type "in" Context -> VarInContextJudgment {cons("VarInContextJudgment")}
		
		Expr "=" Expr -> EqualityJudgment {cons("EqualityJudgementE"), prefer}
		Type "=" Type -> EqualityJudgment {cons("EqualityJudgementT")}
		Context "=" Context -> EqualityJudgment {cons("EqualityJudgementC"), avoid}
		
		Expr "!=" Expr -> EqualityJudgment {cons("NotEqualityJudgementE"), prefer}
		Type "!=" Type -> EqualityJudgment {cons("NotEqualityJudgementT")}
		Context "!=" Context -> EqualityJudgment {cons("NotEqualityJudgementC"), avoid}
		
		"exists" {Meta ","}+ TypingRuleJudgementList -> ExistsJudgment {cons("ExistsJudgment"), layout("1.first.col < 3.first.col && 1.first.line < 3.first.line")}
		
		Expr "->" Expr -> ReductionJudgment {cons("ReductionJudgment")}
		
		TypingJudgment -> TypingRuleJudgment
		VarInContextJudgment  -> TypingRuleJudgment
		EqualityJudgment -> TypingRuleJudgment
		ExistsJudgment -> TypingRuleJudgment
		ReductionJudgment -> TypingRuleJudgment
		
	sorts Module Rules DerivedRules Import Imports ModuleDec Qualified Definitions
	
	lexical syntax
		~[\"\n\r\t\ ]+ -> TerminalLex
		[a-zA-Z][a-zA-Z0-9]* -> Nonterminal
	lexical restrictions
		TerminalLex -/- ~[\"\n\r\t\ ]
		Nonterminal -/- [a-zA-Z0-9]
		
	
	context-free syntax
		Nonterminal "::=" {SyntaxRHS "|"}+ -> SyntaxDef {cons("SyntaxDef")}
		
		"\"" TerminalLex "\"" -> Terminal {bracket}
		Terminal -> SyntaxRHSElem {cons("Terminal")}
		Nonterminal -> SyntaxRHSElem {cons("Nonterminal")}
		SyntaxRHSElem+ -> SyntaxRHS
	
	context-free syntax
		"import" MID -> Import {cons("Import")}
		
		"local" "{" ModuleDef* "}" -> ModuleDef {cons("Local")}
		"syntax" SyntaxDef* -> ModuleDef {cons("Syntax")}
		"axioms" TypingRule* -> ModuleDef {cons("Axioms")}
		"axiom" TypingRule* -> ModuleDef {ast("Axioms([<1>])")}
		
		"goals" TypingRule* -> ModuleDef {cons("Goals")}
		"goal" TypingRule -> ModuleDef {ast("Goals([<1>])")}
		
		
		%% TODO: Make derived rules optional
		"module" MID Import* ModuleDef*-> Module {cons("Module")}
								
	context-free start-symbols Module
