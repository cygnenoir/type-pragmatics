module encodingcompstudyQL.QLSemantics

import encodingcompstudyQL.QLSyntax

//type for (intermediate) results (IR) of questionnaire reduction
data IR = error | final(QuestConfExp) | part(QuestConfExp, AvList)

function 
IRsuccess: IR -> Bool
IRsuccess(error) = false
IRsuccess(final(qce)) = true
IRsuccess(part(qce, avl)) = true

function
IRfinal: IR -> Bool
IRfinal(error) = false
IRfinal(final(qce)) = true
IRfinal(part(qce, avl)) = false

//functions for decomposing an IR
//important: sensible values for final results!
partial function 
getQuestIR : IR -> Quest
getQuestIR(final(qce)) = getQuest(qce)
getQuestIR(part(qce, avl)) = getQuest(qce)

partial function
getAv : IR -> AvList
getAv(final(am)) = aempty
getAv(part(qce, avl)) = avl

partial function
getAmIR : IR -> AnsMap
getAmIR(final(qce)) = getAM(qce)
getAmIR(part(qce, avl)) = getAM(qce)

//function for evaluating expressions
//TODO
function
evalExp : Exp AnsMap -> Bool

//main reduction function, for reducing configurations of answermaps and questionnaires to configurations of answermaps and questionnaires
//arguments: QuestConfExp: (remaining) questionnaire configuration (in which AnswerMap contains all previously given answers, and quest is the remaining questionnaire)
//AvList: remaining input answer values (consumed during reduction)
function
reduce: QuestConfExp AvList -> IR
reduce(C(am, qempty), avempty) = final(C(am, qempty)) //success case
reduce(C(am, qempty), av) = part(C(am, qempty), av) //case: too many answers (for this subexpression at least) - should this be an error case? - but then reduction of sequences will not work when seq(qempty,q) was already in input program!
reduce(C(am, q), avempty) = error //error case: too few answers
reduce(C(am, question(qid, at, l)), avcons(av, avempty)) = final(C(appendAnsMap(am, abind(qid, av, aempty)), qempty))
//blindly consume an answer - should this dynamically fail if types are not correct?
reduce(C(am, question(qid, at, l)), avcons(av, avr)) = part(C(appendAnsMap(am, abind(qid, av, aempty)), qempty), avr)
reduce(C(am, seq(q1, q2)), av) = 
	let ir1 = reduce(C(am, q1), av) in 
		if (IRsuccess(ir1))
		then let rquest = getQuestIR(ir1) in
			let avr = getAv(ir1) in
			let amr = getAmIR(ir1) in
				if (rquest = qempty)
				then part(C(amr,q2), avr)
				else part(C(amr,seq(rquest, q2)), avr)
		else error
reduce(C(am, condquestion(e, q1, q2)), av) =
	if (evalExp(e, am))
	then part(C(am, q1), av)
	else part(C(am, q2), av)
