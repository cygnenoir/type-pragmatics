module encodingcompstudyQL.QLSemantics

import encodingcompstudyQL.QLSyntax
import encodingcompstudyQL.BasicTypes

//answer oracle for Boolean questions
function 
askYesNo : Label -> YN

//answer oracle for Numbers
function
askNumber : Label -> nat

//answer orcale for strings
function
askString : Label -> string

//convenience function for asking the right oracle, given a question label and an answer type
function
getAnswer : Label AType -> Aval
getAnswer(l, YesNo) = B(askYesNo(l))
getAnswer(l, Number) = Num(askNumber(l))
getAnswer(l, Text) = T(askString(l))


data EBool = True | False | Error

function
comparable: Aval Aval -> Bool
comparable(av1, av2) = typeOf(av1) == typeOf(av2)

//function for evaluating expressions
//this function should fail if it does not find an answer in the given AnsMap
// function
// evalExp : Exp AnsMap -> EBool
// evalExp(Eq(qid, av), am) = 
// 	let avo = lookupAnsMap(qid, am) in
// 		if (isSomeAval(avo))
// 		then let av2 = getAval(av2) in
// 			if (comparable(av2, av))
// 		 	then if (av2 == av) then True else False
// 		 	else Error
// 		 else Error 
// evalExp(Gt(qid, n), am) = 
// 	let avo = lookupAnsMap(qid, am) in
// 		if (isSomeAval(avo))
// 		then let av2 = getAval(av2) in
// 			if (typeOf(av2) == Number)
// 			then if (gt(av2, n)) then True else False
// 			else Error
// 		else Error
// evalExp(Lt(qid, n), am) = 
// 	let avo = lookupAnsMap(qid, am) in
// 		if (isSomeAval(avo))
// 		then let av2 = getAval(av2) in
// 			if (typeOf(av2) == Number)
// 			then if (lt(av2, n)) then True else False
// 			else Error
// 		else Error
// evalExp(ETrue, am) = True
// evalExp(Not(e), am) = 
// 	let evale = evalExp(e, am) in
// 	if (evale == True) 
// 	then False
// 	else if (evale == False)
// 		then True
// 		else Error
// evalExp(And(e1, e2), am) = 
// 	let evale1 = evalExp(e1, am) in
// 		let evale2 = evalExp(e2, am) in
// 		 if ((evale1 == Error) || (evale2 == Error))
// 		 then Error
// 		 else if (evale1 == False)
// 		 	then False
// 		 	else evale2




//main reduction function, for reducing configurations of answermaps and questionnaires to configurations of answermaps and questionnaires
//argument QC: (remaining) questionnaire configuration 
//(in which AnsMap contains all previously given answers - and qb is the remaining questionnaire block)
//returns: Option of QC (where AnsMap contains all answers to the previous questions, 
//qb the remaining questionnaire block)
function
reduce: QC -> OptQC
reduce(C(am, qempty)) = noQC //cannot reduce value configuration further
reduce(C(am, qsingle(q))) = noQC
reduce(C(am, qdef(q))) = noQC
reduce(C(am, qseq(q1, q2))) = 
	if (isValue(q1))
	then someQC(C(am, q2))
	else let reduceqb1 = reduce(C(am, q1)) in
			if (isSomeQC(reduceqb1))
			then let qc1n = getQC(reduceqb1) in
				someQC(C(getAM(qc1n), qseq(getQuest(qc1n), q2)))
			else noQC
reduce(C(am, qcond(p, q1, q2))) = noQC
reduce(C(am, qgroup(gid, q))) = noQC



// function
// reduce: QC -> OptQC
// reduce(C(am, qempty)) = noQC //cannot reduce value configuration further
// reduce(C(am, qcons(question(qid, at, l), qbr))) =
// 	//look up the correctly typed answer in the magic allAnswers function 
// 	let ans = getAnswer(l, at) in 
// 		//preserve the order of the questions in the answer map?
// 		//could be important for type preservation (alternatively, typing could reverse answermap...)
// 		someQC(C(appendAnsMap(am, abind(qid, ans, aempty)), qbr))
// reduce(C(am, qseq(qb1, qb2))) = 
// 	if (isValue(qb1))
// 	then someQC(C(am, qb2))
// 	else let reduceqb1 = reduce(C(am, qb1)) in
// 			if (isSomeQC(reduceqb1))
// 			then let qc1n = getQC(reduceqb1) in
// 				someQC(C(getAM(qc1n), qseq(getQuest(qc1n), qb2)))
// 			else noQC
// //qcond is the only case where evaluation can actually dynamically fail!
// reduce(C(am, qcond(exp, qb1, qb2))) =
// 	let eExp = evalExp(exp, am) in
// 		if (eExp == Error)
// 		then noQC
// 		else if (eExp == True)
// 			then someQC(C(am, qb1))
// 			else someQC(C(am, qb2))
