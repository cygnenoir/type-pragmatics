module encodingcompstudyQL.QLSemantics

import encodingcompstudyQL.QLSyntax
import encodingcompstudyQL.BasicTypes

//answer oracle for Boolean questions
function 
askYesNo : Label -> YN

//answer oracle for Numbers
function
askNumber : Label -> nat

//answer orcale for strings
function
askString : Label -> string

//convenience function for asking the right oracle, given a question label and an answer type
function
getAnswer : Label AType -> Aval
getAnswer(l, YesNo) = B(askYesNo(l))
getAnswer(l, Number) = Num(askNumber(l))
getAnswer(l, Text) = T(askString(l))


function
evalBinOp : BinOp Aval Aval -> OptAval
evalBinOp(add(), Num(n1), Num(n2)) = someAval(Num(plus(n1, n2)))
evalBinOp(sub(), Num(n1), Num(n2)) = someAval(Num(minus(n1, n2)))
evalBinOp(mul(), Num(n1), Num(n2)) = someAval(Num(multiply(n1, n2)))
evalBinOp(div(), Num(n1), Num(n2)) = someAval(Num(divide(n1, n2)))
evalBinOp(gt(), Num(n1), Num(n2)) = someAval(B(gt(n1, n2)))
evalBinOp(lt(), Num(n1), Num(n2)) = someAval(B(lt(n1, n2)))
evalBinOp(and(), B(b1), B(b2)) = someAval(B(and(n1, n2)))
evalBinOp(or(), B(b2), B(b2)) = someAval(B(or(n1, n2)))
evalBinOp(eq(), Num(n1), Num(n2)) = if (n1 == n2) then someAval(B(yes)) else someAval(B(no))
evalBinOp(eq(), B(b1), B(b2)) = if (b1 == b2) then someAval(B(yes)) else someAval(B(no))
evalBinOp(eq(), T(t1), T(t2)) = if (t1 == t2) then someAval(B(yes)) else someAval(B(no))
evalBinOp(op, a1, a2) = noAval

function
evalUnOp : UnOp Aval -> OptAval
evalUnOp(not(), B(b)) = someAval(B(not(b)))
evalUnOp(op, a) = noAval

//function for evaluating expressions
//this function should fail if it does not find an answer in the given AnsMap
function
evalExp : Exp AnsMap -> OptAval
evalExp(constant(av), am) = someAval(av)
evalExp(qvar(qid), am) = lookupAnsMap(qid, am)
evalExp(binop(e1, op, e2), am) =
    let avOpt1 = evalExp(e1, am) in
    let avOpt2 = evalExp(e2, am) in
        if (isSomeAval(avOpt1) && isSomeAval(avOpt2))
        then evalBinOp(op, getAval(avOpt1), getAval(avOpt2))
	else noAval
evalExp(unop(op, e), am) =
    let avOpt = evalExp(e, am) in
        if (isSomeAval(avOpt))
        then evalUnOp(op, getAval(avOpt))
	else noAval


// function
// evalExp : Exp AnsMap -> EBool
// evalExp(Eq(qid, av), am) = 
// 	let avo = lookupAnsMap(qid, am) in
// 		if (isSomeAval(avo))
// 		then let av2 = getAval(av2) in
// 			if (comparable(av2, av))
// 		 	then if (av2 == av) then True else False
// 		 	else Error
// 		 else Error 
// evalExp(Gt(qid, n), am) = 
// 	let avo = lookupAnsMap(qid, am) in
// 		if (isSomeAval(avo))
// 		then let av2 = getAval(av2) in
// 			if (typeOf(av2) == Number)
// 			then if (gt(av2, n)) then True else False
// 			else Error
// 		else Error
// evalExp(Lt(qid, n), am) = 
// 	let avo = lookupAnsMap(qid, am) in
// 		if (isSomeAval(avo))
// 		then let av2 = getAval(av2) in
// 			if (typeOf(av2) == Number)
// 			then if (lt(av2, n)) then True else False
// 			else Error
// 		else Error
// evalExp(ETrue, am) = True
// evalExp(Not(e), am) = 
// 	let evale = evalExp(e, am) in
// 	if (evale == True) 
// 	then False
// 	else if (evale == False)
// 		then True
// 		else Error
// evalExp(And(e1, e2), am) = 
// 	let evale1 = evalExp(e1, am) in
// 		let evale2 = evalExp(e2, am) in
// 		 if ((evale1 == Error) || (evale2 == Error))
// 		 then Error
// 		 else if (evale1 == False)
// 		 	then False
// 		 	else evale2




//main reduction function, for reducing configurations of answermaps and questionnaires to configurations of answermaps and questionnaires
//argument QC: (remaining) questionnaire configuration 
//(in which AnsMap contains all previously given answers - and qb is the remaining questionnaire block)
//returns: Option of QC (where AnsMap contains all answers to the previous questions, 
//qb the remaining questionnaire block)
function
reduce: QC -> OptQC
reduce(C(am, qempty)) = noQC //cannot reduce value configuration further
reduce(C(am, qsingle(q))) = noQC
reduce(C(am, qdef(q))) = noQC
reduce(C(am, qseq(q1, q2))) = 
	if (isValue(q1))
	then someQC(C(am, q2))
	else let reduceqb1 = reduce(C(am, q1)) in
			if (isSomeQC(reduceqb1))
			then let qc1n = getQC(reduceqb1) in
				someQC(C(getAM(qc1n), qseq(getQuest(qc1n), q2)))
			else noQC
reduce(C(am, qcond(p, q1, q2))) = noQC
reduce(C(am, qgroup(gid, q))) = noQC



// function
// reduce: QC -> OptQC
// reduce(C(am, qempty)) = noQC //cannot reduce value configuration further
// reduce(C(am, qcons(question(qid, at, l), qbr))) =
// 	//look up the correctly typed answer in the magic allAnswers function 
// 	let ans = getAnswer(l, at) in 
// 		//preserve the order of the questions in the answer map?
// 		//could be important for type preservation (alternatively, typing could reverse answermap...)
// 		someQC(C(appendAnsMap(am, abind(qid, ans, aempty)), qbr))
// reduce(C(am, qseq(qb1, qb2))) = 
// 	if (isValue(qb1))
// 	then someQC(C(am, qb2))
// 	else let reduceqb1 = reduce(C(am, qb1)) in
// 			if (isSomeQC(reduceqb1))
// 			then let qc1n = getQC(reduceqb1) in
// 				someQC(C(getAM(qc1n), qseq(getQuest(qc1n), qb2)))
// 			else noQC
// //qcond is the only case where evaluation can actually dynamically fail!
// reduce(C(am, qcond(exp, qb1, qb2))) =
// 	let eExp = evalExp(exp, am) in
// 		if (eExp == Error)
// 		then noQC
// 		else if (eExp == True)
// 			then someQC(C(am, qb1))
// 			else someQC(C(am, qb2))
