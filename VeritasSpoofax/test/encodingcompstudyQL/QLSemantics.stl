module encodingcompstudyQL.QLSemantics

import encodingcompstudyQL.QLSyntax

data OptQC = noQC | someQC(QC)

function
isSomeQC : OptQC -> Bool
isSomeQC(noQC) = false
isSomeQC(someQC(qc)) = true

partial function 
getQC : OptQC -> QC
getQC(someQC(qc)) = qc


//function for evaluating expressions
//TODO: this function should fail if it does not find an answer in the given AnsMap...?!
//just returning a bool would mean that the semantics cannot ever fail...
function
evalExp : Exp AnsMap -> Bool



//main reduction function, for reducing configurations of answermaps and questionnaires to configurations of answermaps and questionnaires
//argument QC: (remaining) questionnaire configuration (in which AnsMap contains all previously given answers - and qb is the remaining questionnaire block)
//returns: Option of QC (where AnsMap contains all answers to the previous questions, qb the remaining questionnaire block)
function
reduce: QC -> OptQC
reduce(C(am, qempty)) = noQC //cannot reduce value further
reduce(C(am, qcons(question(qid, at, l), qbr))) =
	//look up the correctly typed answer in the magic allAnswers function 
	let ans = allAnswers(qid, at) in 
		//preserve the order of the questions in the answer map?
		//important for type preservation (alternatively, typing could reverse answermap...)
		someQC(C(appendAnsMap(am, abind(qid, ans, aempty)), qbr))
reduce(C(am, qseq(qb1, qb2))) = 
	if (isValue(qb1))
	then someQC(C(am, qb2))
	else let reduceqb1 = reduce(C(am, qb1)) in
			if (isSomeQC(reduceqb1))
			then let qc1n = getQC(reduceqb1) in
				someQC(C(getAM(qc1n), qseq(getQuest(qc1n), qb2)))
			else noQC
reduce(C(am, qcond(exp, qb1, qb2))) = 
	if (evalExp(exp, am))
	then someQC(C(am, qb1))
	else someQC(C(am, qb2))
