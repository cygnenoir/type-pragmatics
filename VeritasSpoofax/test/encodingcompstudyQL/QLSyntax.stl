module encodingcompstudyQL.QLSyntax

import encodingcompstudyQL.BasicTypes

// question identifiers
open data QID

// identifiers/titles for question groups
open data GID

// label (text) of questions, underspecified
open data Label

// sum type for different concrete answers 
// so far omits date, decimal, and money/currency from the original spec
data Aval = B(YN) | Num(nat) | T(string)

//Option[Aval]

data OptAval =
	noAval |
	someAval(Aval)

function
isSomeAval : OptAval -> Bool
isSomeAval(noAval) = false
isSomeAval(someAval(t)) = true

partial function
getAval : OptAval -> Aval
getAval(someAval(t)) = t

//answer type for questions
data AType = YesNo | Number | Text

//type of each Aval
function
typeOf : Aval -> AType
typeOf(B(yn)) = YesNo
typeOf(Num(n)) = Number
typeOf(T(s)) = Text

//list of answer types
data ATList = atempty | atcons(AType, ATList)


function 
append: ATList ATList -> ATList
append(atempty, atl) = atl
append(atcons(at, atlr), atl) = atcons(at, append(atlr, atl))

	
// expressions for conditional guard
data Exp = constant(Aval) | qvar(QID) | 
	add(Exp, Exp) | sub(Exp, Exp) | mul(Exp, Exp) | div(Exp, Exp)

//no explicit constructs for <=, >=, != - can easily be constructed
//with the constructs below
data Pred = 
	Eq(Exp, Exp) | 
	Gt(Exp, Exp) | 
	Lt(Exp, Exp) |
  	ETrue | 
  	Not(Pred) | 
  	And(Pred, Pred) |
  	Or(Pred, Pred)

// datatype for (simple) questions
//QID: id of question, Label: question text, AType: type of answer,
//dquestion: question derived via an expression (will have type of that expression)
//dpquestion: question derived via a predicate (must be checked to have Boolean type)
data Q = question(QID, Label, AType) | dquestion(QID, Exp) | dpquestion(QID, Pred)

//Questionnaire
//qempty: empty questionnaire
//qsingle: single (derived) question
//qdef: definition of a question (will not directly ask the question - but qid can be used later to actually ask it)
//qseq: sequential composition of questionnaires
//qcond: conditional questions (depend on evaluation of a predicate)
//qgroup: grouping construct for hierarchical questionnaires
data Questionnaire = 
	qempty |
	qsingle(Q) |
	qdef(Q) |
	qseq(Questionnaire, Questionnaire) |
	qcond(Pred, Questionnaire, Questionnaire) |
	qgroup(GID, Questionnaire)
	


// map of answers to questions ("flat")
data AnsMap = aempty | abind(QID, Aval, AnsMap)

function lookupAnsMap : QID AnsMap -> OptAval
lookupAnsMap(qid, aempty) = noAval
lookupStore(qid1, abind(qid2, av, AM)) = 
	if (qid1 == qid2)
	then someAval(av)
	else lookupAnsMap(qid1, AM)


//will probably primarily use this to attach one element to the end of an AnsMap
//maybe specify a more specialized function for this?
function 
appendAnsMap : AnsMap AnsMap -> AnsMap
appendAnsMap(aempty, am) = am
appendAnsMap(abind(qid, av, am), aml) = abind(qid, av, appendAnsMap(am, aml))

//main expressions ("questionnaire configurations"): combination of AnsMap (of already given answers) and remaining questions
//this is the expression to be reduced!
data QC = C(AnsMap, Questionnaire)

function
getAM : QC -> AnsMap
getAM(C(am, q)) = am

function
getQuest : QC -> Questionnaire
getQuest(C(am, q)) = q

function
isValue : QC -> Bool
isValue(C(am, qempty)) = true
isValue(C(am, qb)) = false

data OptQC = noQC | someQC(QC)

function
isSomeQC : OptQC -> Bool
isSomeQC(noQC) = false
isSomeQC(someQC(qc)) = true

partial function 
getQC : OptQC -> QC
getQC(someQC(qc)) = qc




