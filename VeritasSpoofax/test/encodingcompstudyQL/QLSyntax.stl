module encodingcompstudyQL.QLSyntax

import encodingcompstudyQL.BasicTypes

// question identifiers
open data QID

// identifiers/titles for question groups
open data GID

// label (text) of questions, underspecified
open data Label

// sum type for different concrete answers 
// so far omits date, decimal, and money/currency from the original spec
data Aval = B(YN) | Num(nat) | T(string)

//Option[Aval]

data OptAval =
	noAval |
	someAval(Aval)

function
isSomeAval : OptAval -> Bool
isSomeAval(noAval) = false
isSomeAval(someAval(t)) = true

partial function
getAval : OptAval -> Aval
getAval(someAval(t)) = t

//answer type for questions
data AType = YesNo | Number | Text

//type of each Aval
function
typeOf : Aval -> AType
typeOf(B(yn)) = YesNo
typeOf(Num(n)) = Number
typeOf(T(s)) = Text

//list of answer types
data ATList = atempty | atcons(AType, ATList)


function 
append: ATList ATList -> ATList
append(atempty, atl) = atl
append(atcons(at, atlr), atl) = atcons(at, append(atlr, atl))

data BinOp = add | sub | mul | div | eq | gt | lt | and | or
data UnOp = not

// expressions for conditional guards and derived values
data Exp =
     constant(Aval) |
     qvar(QID) |
     binop(Exp, BinOp, Exp) |
     unop(UnOp, Exp)

// datatype for (simple) questions
// question: QID: id of question, Label: question text, AType: type of answer,
// value: value derived via an expression (will have type of that expression)
// defquestion: definition of a question (will not directly ask the question - but qid can be used later to actually ask it)
// ask: ask a previously defined question
data Entry =
     question(QID, Label, AType) |
     value(QID, AType, Exp) |
     defquestion(QID, Label, AType) |
     ask(QID)

//Questionnaire
//qempty: empty questionnaire
//qsingle: single (derived) question
//qseq: sequential composition of questionnaires
//qcond: conditional questions (depend on evaluation of a predicate)
//qgroup: grouping construct for hierarchical questionnaires
data Questionnaire = 
	qempty |
	qsingle(Q) |
	qseq(Questionnaire, Questionnaire) |
	qcond(Exp, Questionnaire, Questionnaire) |
	qgroup(GID, Questionnaire)
	


// map of answers to questions ("flat")
//ignores hierarchical answer structure of groups - TODO is that ok?
data AnsMap = aempty | abind(QID, Aval, AnsMap)

function lookupAnsMap : QID AnsMap -> OptAval
lookupAnsMap(qid, aempty) = noAval
lookupStore(qid1, abind(qid2, av, AM)) = 
	if (qid1 == qid2)
	then someAval(av)
	else lookupAnsMap(qid1, AM)


//will probably primarily use this to attach one element to the end of an AnsMap
//maybe specify a more specialized function for this?
function 
appendAnsMap : AnsMap AnsMap -> AnsMap
appendAnsMap(aempty, am) = am
appendAnsMap(abind(qid, av, am), aml) = abind(qid, av, appendAnsMap(am, aml))

//main expressions ("questionnaire configurations"): combination of AnsMap (of already given answers) and remaining questions
//this is the expression to be reduced!
data QC = C(AnsMap, Questionnaire)

function
getAM : QC -> AnsMap
getAM(C(am, q)) = am

function
getQuest : QC -> Questionnaire
getQuest(C(am, q)) = q

function
isValue : QC -> Bool
isValue(C(am, qempty)) = true
isValue(C(am, qb)) = false

data OptQC = noQC | someQC(QC)

function
isSomeQC : OptQC -> Bool
isSomeQC(noQC) = false
isSomeQC(someQC(qc)) = true

partial function 
getQC : OptQC -> QC
getQC(someQC(qc)) = qc




