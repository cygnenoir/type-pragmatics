module encodingcompstudyQL.QLTypeSystem

import encodingcompstudyQL.QLSyntax
import encodingcompstudyQL.QLSemanticsData
import encodingcompstudyQL.QLSemantics

//TODO: should we explicitly specify all maps so that duplicate entries simply cannot occur?
//e.g. one could simply not prepend an entry if lookup of the entry in the old map returns a result
//or, more complicated, replace the old entry in the map with the new one (Ã  la Scala maps) 

// type map, used for answer types and types of answers to derived questions
data ATMap = atmempty | atmbind(QID, AType, ATMap)

function
lookupATMap : QID ATMap -> OptAType
lookupATMap(qid, atmempty) = noAType
lookupATMap(qid1, atmbind(qid2, at, tm)) = 
	if (qid1 == qid2)
	then someAType(at)
	else lookupATMap(qid1, tm)
	
function 
appendATMap : ATMap ATMap -> ATMap
appendATMap(atmempty, atm) = atm
appendATMap(atmbind(qid, at, atm), atml) = atmbind(qid, at, appendATMap(atm, atml))


//Pair of ATMap (for answer types of questions that have been or will be directly asked) and QMap (defined questions that can be asked later)
data MapConf = MC(ATMap, QMap)

function 
intersectATM : ATMap ATMap -> ATMap
intersectATM(atmempty, atm2) = atmempty
intersectATM(atmbind(qid, at, atm1), atm2) = 
	let atm1atm2 = intersectATM(atm1, atm2) in
		if (isSomeAType(lookupATMap(qid, atm2)))
		then atmbind(qid, at, atm1atm2)
		else atm1atm2

function 
intersectQM : QMap QMap -> QMap
intersectQM(qmempty, qm2) = qmempty
intersectQM(qmbind(qid, l, at, qm1), qm2) = 
	let qm1qm2 = intersectQM(qm1, qm2) in
		if (isSomeQuestion(lookupQMap(qid, qm2)))
		then qmbind(qid, l, at, qm1qm2)
		else qm1qm2

function
intersectMC : MapConf MapConf -> MapConf
intersectMC(MC(atm1, qm1), MC(atm2, qm2)) = MC(intersectATM(atm1, atm2), intersectQM(qm1, qm2))
	
data OptMapConf = noMapConf | someMapConf(MapConf)

function
isSomeMapConf : OptMapConf -> Bool
isSomeMapConf(noMapConf) = false
isSomeMapConf(someMapConf(mc)) = true

partial function 
getMapConf : OptMapConf -> MapConf
getMapConf(someMapConf(mc)) = mc

//type an AnswerMap:
function typeAM : AnsMap -> ATMap
typeAM(aempty) = atmempty
typeAM(abind(qid, av, am)) = atmbind(qid, typeOf(av), typeAM(am))


function
checkBinOp : BinOp AType AType -> OptAType
checkBinOp(addop, Number(), Number()) = someAType(Number())
checkBinOp(subop, Number(), Number()) = someAType(Number())
checkBinOp(mulop, Number(), Number()) = someAType(Number())
checkBinOp(divop, Number(), Number()) = someAType(Number())
checkBinOp(gtop, Number(), Number()) = someAType(YesNo())
checkBinOp(ltop, Number(), Number()) = someAType(YesNo())
checkBinOp(andop, YesNo(), YesNo()) = someAType(YesNo())
checkBinOp(orop, YesNo(), YesNo()) = someAType(YesNo())
checkBinOp(eqop, Number(), Number()) = someAType(YesNo())
checkBinOp(eqop, YesNo(), YesNo()) = someAType(YesNo())
checkBinOp(eqop, Text(), Text()) = someAType(YesNo())
checkBinOp(op, t1, t2) = noAType

function
checkUnOp : UnOp AType -> OptAType
checkUnOp(notop, YesNo()) = someAType(YesNo())
checkUnOp(op, t) = noAType

function
echeck : ATMap Exp -> OptAType

echeck(tm, constant(B(n))) = someAType(YesNo)
echeck(tm, constant(Num(n))) = someAType(Number)
echeck(tm, constant(T(n))) = someAType(Text)

echeck(tm, qvar(qid)) = lookupATMap(qid, tm)

echeck(tm, binop(e1, op, e2)) =
    let t1 = echeck(tm, e1) in
    let t2 = echeck(tm, e2) in
        if (isSomeAType(t1) && isSomeAType(t2))
	then checkBinOp(op, getAType(t1), getAType(t2))
	else noAType

echeck(tm, unop(op, e)) =
    let t = echeck(tm, e) in
        if (isSomeAType(t))
	then checkUnOp(op, getAType(t))
	else noAType
	
function
entryCheck : ATMap QMap Entry -> OptMapConf
entryCheck(atm, qm, question(qid, l, at)) = someMapConf(MC(atmbind(qid, at, atm), qm))
entryCheck(atm, qm, value(qid, at, exp)) = 
	let eco = echeck(atm, exp) in
		if (isSomeAType(eco))
		then someMapConf(MC(atmbind(qid, getAType(eco), atm), qm))
		else noMapConf
entryCheck(atm, qm, defquestion(qid, l, at)) = someMapConf(MC(atm, qmbind(qid, l, at, qm)))
entryCheck(atm, qm, ask(qid)) = 
	let lmqid = lookupQMap(qid, qm) in
		if (isSomeQuestion(lmqid))
		then someMapConf(MC(atmbind(getQuestionQID(lmqid), getQuestionAType(lmqid), atm), qm)) //do not remove question from QMap! (could be used again later)
		else noMapConf
	
	
//Typing judgment for questionnaires: MapConf |- Questionnaire : MapConf
//first MapConf: MC(ATMap, QMap) that is valid *before* questionnaire
//second MapConf: MC(ATMap, QMap) that is valid *after* questionnaire (includes all bindings from first MapConf!!)

axiom

======================================== T-qempty
~MC |- qempty : ~MC

axiom
entryCheck(~atm1, ~qm1, ~entry) == someMapConf(MC(~atm2, ~qm2))
================================================================ T-qsingle
MC(~atm1, ~qm1) |- qsingle(~entry) : MC(~atm2, ~qm2)


axiom
MC(~atm1, ~qm1) |- ~q1 : MC(~atm2, ~qm2)
MC(~atm2, ~qm2) |- ~q2 : MC(~atm3, ~qm3)
===================================================== T-qseq
MC(~atm1, ~qm1) |- qseq(~q1, ~q2) : MC(~atm3, ~qm3)


axiom 
echeck(~atm1, ~exp) == someAType(~at)
MC(~atm1, ~qm1) |- ~q1 : MC(~atm2, ~qm2)
MC(~atm1, ~qm1) |- ~q2 : MC(~atm3, ~qm3)
intersectMC(MC(~atm2, ~qm2), MC(~atm3, ~qm3)) == MC(~atm4, ~qm4) 
==================================================================== T-qcond
MC(~atm1, ~qm1) |- qcond(~exp, ~q1, ~q2) : MC(~atm4, ~qm4)


axiom
MC(~atm1, ~qm1) |- ~q : MC(~atm2, ~qm2)
======================================================== T-qgroup
MC(~atm1, ~qm1) |- qgroup(~gid, ~q) : MC(~atm2, ~qm2)




//Main typing function for questionnaire configurations (axiomatic specification?)
function
qcCheck : QConf -> ATMap

axiom
typeAM(~am) == ~atm1
MC(~atm1, ~qm) |- ~q : MC(~atm2, ~qm2)
======================================== T-qcCheck
qcCheck(QC(~am, ~qm, ~q)) == ~atm2 //<<-- this is the ATMap that shall stay "equal" during reduction, where "equal" means "if a binding in the map was present before a step, it has to be present after the step" (after a step, a map potentially contains more bindings!)

