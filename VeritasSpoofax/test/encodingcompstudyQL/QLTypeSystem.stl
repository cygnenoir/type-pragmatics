module encodingcompstudyQL.QLTypeSystem

import encodingcompstudyQL.QLSyntax
import encodingcompstudyQL.QLSemanticsData
import encodingcompstudyQL.QLSemantics

// type map, used for answer types and question-definition types
data TMap = tmempty | tmbind(QID, AType, TMap)

function
lookupTMap : QID TMap -> OptAType
lookupTMap(qid, tmempty) = noAType
lookupTMap(qid1, tmbind(qid2, at, tm)) = 
	if (qid1 == qid2)
	then someAType(at)
	else lookupTMap(qid1, tm)

function
checkBinOp : BinOp AType AType -> OptAType
checkBinOp(addop, Number(), Number()) = someAType(Number())
checkBinOp(subop, Number(), Number()) = someAType(Number())
checkBinOp(mulop, Number(), Number()) = someAType(Number())
checkBinOp(divop, Number(), Number()) = someAType(Number())
checkBinOp(gtop, Number(), Number()) = someAType(YesNo())
checkBinOp(ltop, Number(), Number()) = someAType(YesNo())
checkBinOp(andop, YesNo(), YesNo()) = someAType(YesNo())
checkBinOp(orop, YesNo(), YesNo()) = someAType(YesNo())
checkBinOp(eqop, Number(), Number()) = someAType(YesNo())
checkBinOp(eqop, YesNo(), YesNo()) = someAType(YesNo())
checkBinOp(eqop, Text(), Text()) = someAType(YesNo())
checkBinOp(op, t1, t2) = noAType

function
checkUnOp : UnOp AType -> OptAType
checkUnOp(notop, YesNo()) = someAType(YesNo())
checkUnOp(op, t) = noAType

function
echeck : TMap Exp -> OptAType

echeck(tm, constant(B(n))) = someAType(YesNo)
echeck(tm, constant(Num(n))) = someAType(Number)
echeck(tm, constant(T(n))) = someAType(Text)

echeck(tm, qvar(qid)) = lookupTMap(qid, tm)

echeck(tm, binop(e1, op, e2)) =
    let t1 = echeck(tm, e1) in
    let t2 = echeck(tm, e2) in
        if (isSomeAType(t1) && isSomeAType(t2))
	then checkBinOp(op, getAType(t1), getAType(t2))
	else noAType

echeck(tm, unop(op, e)) =
    let t = echeck(tm, e) in
        if (isSomeAType(t))
	then checkUnOp(op, getAType(t))
	else noAType


//TODO: type system should satisfy progress and preservation!
//How to come up with a semantics + type system s.t. reduction does not change the type?
//If the type of a question block is an ATMap, then evaluating the block "shortens" the type
//IDEA: type of AnsMap ++ type of remaining question block does not change during evaluation 
//(i.e. type of QC does not change during reduction)
//PROBLEM: How to deal with types of conditional blocks??

//Type of a questionnaire: QID -> AType map of already given answers
//also serves as environment type for previously given answers
data ATMap = atmempty | atmbind(QID, AType, ATMap)
	
function 
appendATMap : ATMap ATMap -> ATMap
appendATMap(atmempty, atm) = atm
appendATMap(atmbind(qid, at, atm), atml) = atmbind(qid, at, appendATMap(atm, atml))

//type an AnswerMap:
function typeAM : AnsMap -> ATMap
typeAM(aempty) = atmempty
typeAM(abind(qid, av, am)) = atmbind(qid, typeOf(av), typeAM(am))



// OLDER STUFF

//not yet sure whether this is "nice" like this...
//typing judgment: ATMap |- Quest : ATMap
//where first ATMap is the environment of previously given answers, and the second ATMap the "type"
//of Quest

// axiom
// 
// ========================== T-qempty
// ~atm |- qempty : atmempty
// 
// axiom
// 
// =========================================== T-question
// ~atm |- question(~qid, ~at, ~l) : atmbind(~qid, ~at, atmempty)
// 
// axiom
// ~atm1 |- ~q1 : ~atm2
// ~atm2 |- ~q2 : ~atm3 //~atm1 ++ ~atm2 |- ~q2: ~atm3
// =========================================== T-seq
// ~atm1 |- qseq(~q1, ~q2) : appendATMap(~atm2, ~atm3)
// 
// 
// //for now, just enforce that both questions in a conditional branch have
// //to have the same answer type
// //however, intuitively, the answer type could of course differ....
// //(which would complicate type checking a lot)
// 
// //TODO: type expression, with regard to answer map!
// axiom
// ~atm |- ~q1 : ~atm1
// ~atm |- ~q2 : ~atm1
// ============================================= T-condquestion
// ~atm |- qcond(~e, ~q1, ~q2) : ~atm1